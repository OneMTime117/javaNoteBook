# 设计模式  GOF

GOF（Gang of Four），四人组，由四个人共同研究定义的23种设计模式

# 设计模式遵循的7大设计原则：

## 1、单一职责原则：

目的：每各类都应该只有一个单一职责，即只有一种理由去改变类；从而实现代码的易维护、易扩展、易复用

例子：俄罗斯方块

将界面、方块生成、方块移动、方块消除、方块下落功能分成各个类；每个类实现单一职责原则

## 2、依赖倒转原则：

目的：面向接口编程，而不是一开始就面向实现编程；这样可以很好的实现代码的扩展，让细节依赖于抽象，而不是抽象依赖于细节

例子：以多数数据源的JDBC为例，我们应该先定义一个统一的JDBC的接口，然后根据数据源的不同，来进行不同的实现；这样就无需修改调用JDBC方法的代码

## 3、开-闭原则（开放-封闭原则）：

目的：尽量保证类在设计初期就满足，可以通过新增代码的方式，来面对部分需求的变化，而不需要去改变原来代码；实现代码的可维护、可扩展、可复用、灵活性好

例子：以计算器为例，就应该将加减乘除分为四个类，继承相同的运算抽象类；通过新增不同的实现，来满足需求的变化

注意：开闭原则是面向对象设计类的核心所在，但是在实际过程中，并不是需要将所有功能部分进行刻意的抽象，这样会增加代码的复杂度。因此应根据实际情况，只对那些频繁变化的功能部分进行抽象处理，从而通过不同的实现类来满足需求变化。

## 4、迪米特法则：

迪米特法则也叫最少知识原则：如果两个类彼此没有直接通信，就需要保证器类尽可能不能发生直接相互作用，一个对象应当对其他对象有尽可能少的了解

因此在类的结构设计上要保证：

1、每个类尽量降低成员的访问权限，最好为private状态

2、为了降低类之间的耦合，在调用是尽量面向父类、抽象类（接口）编程，在可以执行必要行为的基础上，减少

其他行为的暴露

## 5、里氏替换原则：

目的：用于规范继承的使用，保证父类代码能够被子类完全复用

定义：每个子类都必须能够替换它们的父类，并且行为不会发生变化

## 6、组合/聚合复用原则：

**组合关系和聚合关系的区别：**

组合关系：部分和整体之间具有相同的声明周期，部分会随着整体实例化或消亡；在代码中表现为，部分类为整体类的成员变量，整体类再被创建时，随之初始化

聚合关系：部分和整体之间没有相同的声明周期，整体消亡后部分能独立存在；在代码中表现为，部分类的创建和整体类无关，只是将其指针随着整体来的构造函数，初始化到了成员变量中

**尽量使用组合和聚合，而不是使用继承来实现代码复用**；因为继承会导致父类方法全部暴露给子类，当父类发生变化时，子类也需要随之改变，这样的依赖关系，会影响代码复用的灵活性；同时组合和聚合有助于每个类实现自己单一职责和封装性

## 7、接口隔离原则：

接口建立应该尽量的细化，方法尽量少，保证每个实现它的类，都依赖实现其所有方法；

每个接口应该为自己对应的类服务，而不是去建立一个庞大的接口来依赖所有类去实现；

同时接口数量也要适度，防止设计过于复杂；使用接口最少的方法完成最多的事

# 23种设计模式：

## 1、简单工厂模式：（过于简单，不算23中设计模式）

目的：1、通过使用类的封装特性，将业务逻辑代码和用户操作代码分开

​			2、通过使用类的多态和继承特性，降低相同类型类之间的代码糅合，并且保证了关键特征代码的复用

例子：实现计算器加减乘除

````java
//基础计算类
public class Operation {
	public double numberA = 0;
	public double numberB = 0;

	public double getResult() throws Exception {
		double result = 0;
		return result;
	}
}

//加减乘除计算类
public class OperationAdd extends Operation{
	@Override
	public double getResult() {
		double result = numberA+numberB;
		return result;
	}
}
public class OperationSub extends Operation{
	@Override
	public double getResult() {
		double result = numberA-numberB;
		return result;
	}
}
public class OperationMul extends Operation{
	@Override
	public double getResult() {
		double result = numberA*numberB;
		return result;
	}
}
public class OperationDiv extends Operation {
	@Override
	public double getResult() throws Exception {
		if (numberB==0) {
			throw new Exception("除数不能为0");
		}
		double result = numberA / numberB;
		return result;
	}
}

//计算器简单工厂类
public class OperationFaction {
	public static Operation getOperation(String operation) {
		Operation oper=null;
		switch (operation) {
		case "+":
			oper = new OperationAdd();
			break;
		case "-":
			oper = new OperationSub();
			break;
		case "*":
			oper = new OperationMul();
			break;
		case "/":
			oper = new OperationDiv();
			break;
		}
		return oper;
	}
}

//计算器操作类（main方法）
//简单工厂，计算机加减乘除
public class ComputerMain {
	private static Scanner scanner = new Scanner(System.in);
	
	public static void main(String[] args) {

		System.out.println("请输入第一个数");
		double numberA = scanner.nextDouble();
		System.out.println("请输入第二个数");
		double numberB = scanner.nextDouble();

		System.out.println("请输入计算符号");
		String operation = scanner.next();
		Operation oper = OperationFaction.getOperation(operation);
		
		oper.numberA = numberA;
		oper.numberB = numberB;
		double result = 0;
		try {
			result = oper.getResult();
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println(result);
		System.out.println("结束");
	}
}
````

## 2、策略模式：

目的：将同种类型的算法（策略）以类的形式封装起来，但是不会改变用户使用哪种算法的分支代码

策略模式和简单工厂模式的比较：

​	相同点：都利用了类的三特性（封装、继承、多态），实现代码的复用和低糅合

​	不同点：简单工厂模式通过一个工厂类（Factory）来封装使用类的分支代码，决定使用哪个实现类；而策略模式是通过一个上下文类（Context）来封装调用所有实现类的方法，而使用哪个对应实现类的分支代码还是根据用户操作类代码决定

例子：实现商城各种促销策略

````java
//商城促销打折算法抽象类
public abstract class Strategy {

	public abstract double Algorithm(double original);
}

//折扣算法
public class DiscountStrategy extends Strategy {
	private double discount = 1;

	public DiscountStrategy(String discount) {
		this.discount = Double.parseDouble(discount);
	}

	@Override
	public double Algorithm(double original) {
		double result = original * discount;
		return result;
	}
}

//满减算法
public class FullReductionStrategy extends Strategy {

	private double full = 0.0d;
	private double reduction = 0.0d;

	public FullReductionStrategy(String full, String reduction) {
		this.full = Double.parseDouble(full);
		this.reduction = Double.parseDouble(reduction);
	}

	@Override
	public double Algorithm(double original) {
		double result = original;
		if (original >= full) {
			result = original - reduction;
		}
		return result;
	}
}

//策略上下文
public class StrategyContext {

	Strategy strategy = null;

	public StrategyContext(Strategy strategy) {
		this.strategy = strategy;
	}

	public double getResult(double original) {
		double algorithm = strategy.Algorithm(original);
		return algorithm;
	}
}

public class StrategyMain {

	private static Scanner scanner = new Scanner(System.in);

	public static void main(String[] args) {
		System.out.println("输入当前总计");
		double count = scanner.nextDouble();
		System.out.println("选择折扣模式：6折、7折、8折、满100-50、满200-80");
		String next = scanner.next();

		StrategyContext context = null;
		switch (next) {
		case "6折":
			context = new StrategyContext(new DiscountStrategy("0.6"));
			break;
		case "7折":
			context = new StrategyContext(new DiscountStrategy("0.7"));
			break;
		case "满100-50":
			context = new StrategyContext(new FullReductionStrategy("100", "50"));
			break;
		case "满200-80":
			context = new StrategyContext(new FullReductionStrategy("200", "80"));
			break;
		}
		double result = context.getResult(200);
		System.out.println("总计" + result + "元");
	}
}
````



由此可知，策略模式只是封装了算法（策略），对于使用哪种策略的分支代码并没有封装；因此可以结合简单工厂模式，将分支代码整合到策略模式的上下文中：

````java
	public StrategyContext(String next) {
		Strategy strategy = null;
		switch (next) {
		case "6折":
			strategy =new DiscountStrategy("0.6");
			break;
		case "7折":
			strategy = new DiscountStrategy("0.7");
			break;
		case "满100-50":
			strategy = new FullReductionStrategy("100", "50");
			break;
		case "满200-80":
			strategy = new FullReductionStrategy("200", "80");
			break;
		}
		this.strategy = strategy;
	}
````

**不管是简单工厂模式和策略模式，可以发现当需要添加新的对象（策略）时；都需要去改动选择 工厂类中的对象选择/上下文类中的策略 选择代码**



## 3、装饰模式：

目的：对一个类动态添加其他功能代码（属性、方法）；在不通过增加原有类代码的同时，实现动态新增

使用场景：当一个类大多数情况下，都可以满足需求时，有时会出现需要执行特殊行为，此时就使用修饰模式，将原有类进一步 **动态、透明地 **添加需要的特殊功能，从而修饰成一个新的类；并且可以以此方式按一定顺序添加多种特殊功能

例子：给人进行装扮

```java
//原有类（需要添加新功能）
public class Person {
	protected String name;

	public Person() {

	}

	public Person(String name) {
		this.name = name;
	}

	public void show() {
		System.out.println(name + "准备进行装扮");
	}
}

//基本修饰类（作为修饰类的父类模板）
public class PersonMod extends Person {

	Person person;

	// 修饰（进行空修饰）
	public void mod(Person person) {
		this.person = person;
	}

	@Override
	public void show() {
		if (person != null) {
			person.show();
		}
	}
}

//Tshirts修饰类
public class TShirtsMod extends PersonMod{

	@Override
	public void show() {
		super.show();
		System.out.println("Tshirts");
	}
}

//大裤衩修饰类
public class BigTrouserMod extends PersonMod {

	@Override
	public void show() {
		super.show();
		System.out.println("大T恤");
	}
}

public class ModMain {
	public static void main(String[] args) {
		Person person = new Person("袁欢");
		
		//添加Tshirts修饰类的功能
		TShirtsMod tShirtsMod = new TShirtsMod();
		tShirtsMod.mod(person);
		
		//添加大裤衩修饰类的功能
		BigTrouserMod bigTrouserMod = new BigTrouserMod();
		bigTrouserMod.mod(tShirtsMod);
		
		//执行该类功能（依次实现原有类、Tshirts类、大裤衩类的功能）
		bigTrouserMod.show();
		
	}
}
```

优点：

1、这样写每个新功能时，都可以创建一个修饰类，并且不会与原有类和其他修饰类相关联；

2、这样会比单纯使用类的继承来扩展类的功能更加灵活；

3、通过使用各种修饰类的顺序，可以组合出不同的行为

缺点：

1、会增加多个小类，使程序复杂

2、过于灵活，导致BUG调试时更加繁琐

## 4、代理模式：

目的：通过代理对象来访问目标对象，从而在保证原有对象地开闭原则和单一职责原则的基础上，**对目标对象进行额外的功能扩展或者对目标对象的访问做控制**

分类：静态代理、动态代理

**1、静态代理：**

代理类和目标类实现同一个接口/继承同一个父类，通过代理类来进行目标类的访问

```java
//歌手接口
public interface Singer {

	public void sing();
}

//歌手实现类
public class SingerL implements Singer{

	@Override
	public void sing() {
		System.out.println("刘德华唱歌");
	}
}

//歌手代理类
public class SingerProxy implements Singer {

	private Singer singer;

	public SingerProxy(Singer singer) {
		this.singer = singer;
	}

	@Override
	public void sing() {
		System.out.println("唱歌准备工作");
		singer.sing();
		System.out.println("善后工作");
	}
}

public class ProxyMain {

	public static void main(String[] args) {
		//创建目标对象
		Singer singerL = new SingerL();
		//创建代理对象
		SingerProxy singerProxy = new SingerProxy(singerL);
		singerProxy.sing();
	}
}
```

优点：在不修改目标对象代码下，对其进行扩展

缺点：由于代理类需要和目标对象实现同一接口，因此在接口需要修改时，需要同时修改维护目标类和代理类

**2、动态代理：**

不同手动创建对应的代理类，从对目标对象进行功能扩展；而是通过反射机制，动态生成代理类，并指定代理类中需要添加的代码

其中使用的JDK提供的java.lang.reflect.Proxy对象来创建代理类；使用java.lang.reflect.InvocationHandler接口来添加代理类需要额外执行的代码；因此动态代理也叫JDK代理

```java
		//动态代理
		SingerL singerL = new SingerL();
		Singer singerProxy1 = (Singer)Proxy.newProxyInstance(singerL.getClass().getClassLoader(),
				singerL.getClass().getInterfaces(), 
				(proxy,Method,agrs)->{
					System.out.println("进行动态代理1");
					Object invoke =  Method.invoke(singerL, agrs);
                    System.out.println("进行动态代理2");
                    //invoke为singerL实现类的当前方法的返回值；当return null时，代理类执行返回值就为null
                    return invoke;
					});
		singerProxy1.sing();
```

## 5、工厂方法模式：

目的：在简单工厂模式的基础上，实现了开-闭原则；通过提高工厂类的个数，从而增加代码的可维护

工厂方法和简单工厂：

1、共同点：都是集中封装了对象的创建，降低客户程序和对象的耦合

2、不同点：工厂方法模式是在客户端程序中来判断使用哪个工厂来创建对象；而简单工厂模式是通过客户端传来的参数，在工厂类方法中判断使用哪个对象
同时工厂方法模式在需要改变重复创建的对象时，更加方便，只需要改变对象的工厂类；而简单工厂需要改变每一个实例化的工厂类参数

例子：计算器加减乘除（简单工厂方法基础上）

```java
//工厂类接口
public interface OperationFaction {
	
	public Operation getOperation();

}

//加法工厂类
public class AddFaction implements OperationFaction{

	@Override
	public Operation getOperation() {
		OperationAdd operationAdd = new OperationAdd();
		return operationAdd;
	}
}
//减法工厂类
public class AddFaction implements OperationFaction{

	@Override
	public Operation getOperation() {
		OperationAdd operationAdd = new OperationAdd();
		return operationAdd;
	}
}

//工厂方法，计算机加减乘除
public class ComputerMain {
	private static Scanner scanner = new Scanner(System.in);

	public static void main(String[] args) {

		System.out.println("请输入第一个数");
		double numberA = scanner.nextDouble();
		System.out.println("请输入第二个数");
		double numberB = scanner.nextDouble();

		System.out.println("请输入计算符号");
		String next = scanner.next();

		OperationFaction operF = null;
		switch (next) {
		case "+":
			operF = new AddFaction();
			break;
		case "-":
			operF = new SubFaction();
			break;
		}

		Operation operation = operF.getOperation();
		operation.numberA = numberA;
		operation.numberB = numberB;
		double result = 0;
		try {
			result = operation.getResult();
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println(result);
		System.out.println("结束");
	}

}
```

工厂方法模式就是将分支判断转移到客户端代码中。在进行功能扩展时，使工厂类和对象类满足开-闭原则；只需要新增一对一的工厂类和实现类，而分支代码就在客户端中修改；**但这样每个功能对象都会有一个工厂类，导致类过多**

## 6、原型模式：

目的：从一个对象中创建一个相同的可定制对象，并且不需要知道任何创建细节（即封装完成对象的拷贝）

**拷贝分为浅拷贝和深拷贝，实现方式和拷贝对象就有所不同**

例子：对简历进行拷贝

```java
//工资类
public class Salay implements Cloneable {

	private double money;

	public double getMoney() {
		return money;
	}

	public void setMoney(double money) {
		this.money = money;
	}

	public Object simpleClone() throws CloneNotSupportedException {
		return this.clone();
	}
}

//简历类
public class Resume implements Cloneable {
	private String name;
	private String sex;
	private String age;
	private String work;
	private String company;

	private Salay salay = new Salay();

	// 设置个人信息
	public void setPersonInfo(String name, String sex, String age) {
		this.name = name;
		this.sex = sex;
		this.age = age;
	}

	// 设置工作经历
	public void setWorkExperience(String work, String company) {
		this.work = work;
		this.company = company;
	}

	// 设置希望薪资
	public void setSalay(Integer salay) {
		this.salay.setMoney(salay);
	}

	// 展示简历
	public void display() {
		System.out.println("姓名：" + name);
		System.out.println("性别：" + sex);
		System.out.println("年龄：" + age);
		System.out.println("工作经历：" + work + "在" + company + "公司");
		System.out.println("希望薪资" + salay.getMoney() + "元");
	}

	// 浅拷贝，通过调用object类提供的clone方法
	public Object simpleClone() throws CloneNotSupportedException {
		return this.clone();
	}

	// 深拷贝，创建一个完全不相关的类，并保证类的属性值完全和当前类一致
	// 即基本数据类型和引用类型的值与原对象一样；而不是引用类型变量保存的引用一样
	public Object copy() {
		//通过浅拷贝来获取下一层中引用对象的数据，但是salay中的引用类型还是会与原对象互相影响
		//因此该种方式不是完美的深拷贝，需要根据实际情况深入拷贝多层，并还要避免出现循环引用
		Resume resume = new Resume();
		try {
			Salay clone = (Salay)salay.simpleClone();
			resume.salay=clone;
			
			resume.name=this.name;
			resume.sex=this.sex;
			resume.age=this.age;
			resume.work=this.work;
			resume.company=this.company;
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}					
		return resume;
	}
}

public class CopyMain {

	public static void main(String[] args) {
		Resume resume = new Resume();
		resume.setPersonInfo("yh", "男", "23");
		resume.setWorkExperience("2017-2019 担任后端开发", "信息技术科技有限公司");
		resume.setSalay(10000);
		try {
			Resume simpleClone = (Resume)resume.copy();
			simpleClone.setPersonInfo("zz", "女", "24");
			resume.setSalay(20000);
			
			resume.display();
			simpleClone.display();
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
}
```

由此可知深拷贝更加安全，但是以上方式实现的深拷贝，在目标类引用类型变量比较复杂时，实现比较麻烦，因此有更加好的方式来实现，拷贝工厂：利用反射，来遍历所有需要深拷贝处理的引用类型，无需自己来修改类

## 7、模板方法模式：

目的：利用类的继承，最大程度上实现代码的复用；将重复不变的行为移动到父类，一些特定行为延迟到子类中定义，从而实现以父类作为模板，来创建多个不同特殊行为的子类，极大的减少重复代码，并提高代码的可维护性

例子：学生抄写试卷，并答题

```java
//试卷模板方法类
public class TestPaper {
	
    //抄写题目，并答题（为重复行为）
	public void testQuestion1() {
		System.out.println("第一题，选择题。。。。。");
		System.out.println("答案为"+getAnswer1());
	}
	
	public void testQuestion2() {
		System.out.println("第二题，选择题。。。。。");
		System.out.println("答案为"+getAnswer2());
	}
	
	public void testQuestion3() {
		System.out.println("第三题，选择题。。。。。");
		System.out.println("答案为"+getAnswer3());
	}
	
    //答题结果（为特定不重复行为）
	protected String getAnswer1() {
		return "";
	}
	
	protected String getAnswer2() {
		return "";
	}
	
	protected String getAnswer3() {
		return "";
	}
}

//学生A试卷答题类（子类重写特定行为）
public class TestPaperA extends TestPaper {

	@Override
	protected String getAnswer1() {
		return "a";
	}

	@Override
	protected String getAnswer2() {
		return "b";
	}

	@Override
	protected String getAnswer3() {
		return "c";
	}
}

//学生B试卷答题类
public class TestPaperB extends TestPaper{

	@Override
	protected String getAnswer1() {
		return "c";
	}
	
	@Override
	protected String getAnswer2() {
		return "c";
	}
	
	@Override
	protected String getAnswer3() {
		return "c";
	}
}

//客户端
public class TestPaperMain {

	public static void main(String[] args) {
        //向上转型（只使用父类定义的方法）
		TestPaper testPaperA = new TestPaperA();
		testPaperA.testQuestion1();
		testPaperA.testQuestion2();
		testPaperA.testQuestion3();
		
		TestPaper testPaperB = new TestPaperB();
		testPaperB.testQuestion1();
		testPaperB.testQuestion2();
		testPaperB.testQuestion3();
	}
}
```



## 8、外观模式：

目的：为每个复杂的子系统模块提供一个统一的访问入口；该类可以简化客户端对子系统的调用，从而在内部隐藏调用子系统的复杂过程。

优点：

​	1、通过外观类简化下一级所有子系统的调用，从而降低每一层系统之间的耦合

​	2、完美体现了依赖倒转原则和迪米特法则的思想，即面向接口编程，最小知识原则

​	3、 减少代码重构的工作量，当需要重构整个系统时，只需要通过该外观类，就能快速了解目前系统的功能业务，并快速复用之前的功能

缺点：

​	不满足开-闭原则，当需要扩展功能时，需要对外观类进行较多的修改；因为外观类方法中调用了子系统的复杂过程

例子：javaWeb项目MVC分层，通过controller层面向http接口，作为service层的外观类

## 9、建造者模式：

目的：方便创建复杂的对象，不需要知道该对象的实现过程；对复杂对象的创建过程进行封装，防止错误的创建对象

例子：同类型产品生产

```java
//产品类
public class Product {
	private List<String> parts = new ArrayList<String>();
	
	public  void add(String part) {
		parts.add(part);
	}
	
	public void show() {
		System.out.println("该产品组件有:");
		for (String string : parts) {
			System.out.println(string);
		}
	}
}

//抽象的产品建造者类（定义了产品需要由几个部分构成）
public abstract class ProductBuilder {

	public abstract void buildPartA();
	public abstract void buildPartB();
	public abstract Product getResult();
}

//产品具体建造者类（定义该具体产品的每个部分对应的组件和建造方式）
public class ConcreteBuilder extends ProductBuilder{
	
	//需要建造的产品类
	private Product product=new Product();

	@Override
	public void buildPartA() {
		product.add("部件A");
	}

	@Override
	public void buildPartB() {
		product.add("部件B");
	}

	@Override
	public Product getResult() {
		return product;
	}	
}

//指挥者类，执行具体建造过程,从而隐藏具体建造过程
public class Director {
	public void construct(ProductBuilder builder) {
        //通过建造者类方法的调用顺序，来固定建造流程
		builder.buildPartA();
		builder.buildPartB();
	}
}

public class BiuldMain {

	public static void main(String[] args) {
		//创建具体建造者对象
		ProductBuilder concreteBuilder = new ConcreteBuilder();
		//创建指挥者对象
		Director director = new Director();
		
		//通过指挥者对象来执行建造者对象方法，完成具体建造任务
		director.construct(concreteBuilder);
		Product result = concreteBuilder.getResult();
		result.show();
	}
}
```

应用场景：

1、当对象创建时，初始化参数太多，或者初始化过程太过于复杂时；可以通过建造者模式来固定创建过程，并增加代码的可读性

2、当该复杂对象有固定的初始化流程，但是每个流程节点都可能有一定变化时；通过建造者模式中的具体建造者类的创建来满足这些变化；当然变化种类不能太多，这样会增加建造者类的数量

## 10、观察者模式：

观察者模式，也叫发布-订阅（Publish/Subscribe）模式；定义了一种一对多的依赖关系，当观察者对象监听一个主题对象时，当主题对象发生改变时，能够立刻通知所有观察者对象，更新自己

应用场景：当一个对象改变，需要同时改变其他对象时，并且不知道具体有多少个其他对象需要改变

目的：通过依赖倒转原则，程序面向接口编程，将类一对一之间的依赖耦合，转化为一对多的接口抽象依赖。从而实现一对多发布-订阅功能,同时将主题对象和观察者对象分离开来，降低耦合，使得各自的变化都不会影响另外一边的变化

例子：明星微博订阅

```java
//订阅者接口
public interface Fan {

	//订阅者接收主题消息
	public void update(String message);
} 

//具体订阅者类
public class ConcreteFan implements Fan{
	private String fanName;
	
	public ConcreteFan(String fanName) {
		this.fanName=fanName;
	}

	@Override
	public void update(String message) {
		System.out.println(fanName+"接收到了订阅消息"+message);
	}
}
}

//主题类接口
public interface Subject {

	//添加粉丝订阅者（观察者）
	public void addFans(Fan fan);
	//删除粉丝订阅者（观察者）
	public void deleteFans(Fan fan);
	
	//发布主题消息
	public void pushMess(String message);
}

//具体主题类
public class ConcreteSubject implements Subject{

	//保存所有订阅者集合
	private List<Fan> list= new ArrayList<Fan>();
	
	@Override
	public void addFans(Fan fan) {
		list.add(fan);
	}

	@Override
	public void deleteFans(Fan fan) {
		list.remove(fan);
	}

	@Override
	public void pushMess(String message) {
		for (Fan fan : list) {
			fan.update(message);
		}
	}

}

public class PushMain {

	public static void main(String[] args) {
		//创建观察者
		Fan fanA = new ConcreteFan("yh");
		Fan fanB = new ConcreteFan("zpp");
		
		//观察者进行主题订阅
		Subject subject  = new ConcreteSubject();
		subject.addFans(fanA);
		subject.addFans(fanB);
		
		//主题发布消息，此时观察者得到推送，发生改变
		subject.pushMess("你好");
	}
}
```

## 11、抽象工厂模式：

目的：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类

相对于工厂方法，只是针对一个产品的各种具体实现类进行创建；而抽象工厂类的方法定义了多个抽象产品；并且有多个不同类型的工厂进行不同的具体创建

例子：不同厂商生产电脑配件

```java
//抽象产品类（鼠标）
public interface Mouse {

	public void show();
}

//抽象产品类（键盘）
public interface Keybo {

	public void show();
}

//具体工厂生产的鼠标
public class HpMouse implements Mouse{

	@Override
	public void show() {
		System.out.println("hp生产的鼠标");
	}	
}

//具体工厂生产的键盘
public class HpKeybo implements Keybo{

	@Override
	public void show() {
		System.out.println("hp生产的键盘");
	}
}

//抽象工厂类（目前生产鼠标和键盘）
public interface AbstractFactory {

	public Mouse createMouse(); 
	public Keybo createKeybo(); 
}

//惠普工厂类
public class HpFactory implements AbstractFactory{

	@Override
	public Mouse createMouse() {
		return new HpMouse();
	}

	@Override
	public Keybo createKeybo() {
		return new HpKeybo();
	}
}

public class ProductMain {

	public static void main(String[] args) {
		
		//创建电脑配件工厂（根据具体实现类的不同，来生产各种不同实现类的产品）
		AbstractFactory factory = new HpFactory();
		
		//生产产品
		Keybo createKeybo = factory.createKeybo();
		Mouse createMouse = factory.createMouse();
		
		createKeybo.show();
		createMouse.show();
	}
}
```

优点：

1、满足了多种产品对象的生产，即一个工厂对象可以获取多种类型的对象；

2、由于具体工厂类只初始化一次，并且所有方法都面向抽象；因此只需要修改对应的具体工厂类，就能够改变整个所有具体产品的类型

3、和工厂方法模式一样，通过添加新的具体工厂类和具体产品类；从而实现功能扩展

缺点：

由于抽象工厂类已经确定好了抽象产品的数量，因此无法支持新产品的扩展；否则违反开-闭原则

## 12、状态模式：

目的：在实际情景中，会常常出现分支判断不同状态，从而执行不同的行为；由于状态过多，因此分支判断会非常多，有时状态复杂也会增加分支判断的逻辑；这样大量的分支判断代码，会大大增加方法长度，对于代码的重构，是非常糟糕的

**因此，通过面向对象设计，将代码责任分解，将每种状态的逻辑转移到对应状态类中，从而将复杂的判断逻辑简化**

例子：不同时间点的工作状态

```java
public class Work {

	// 工作状态
	private State state;
	// 当前工作时间点
	private double hour;

	// 工作任务是否完成
	private boolean taskFinished;

	public Work() {
		state = new ForenoonState();// 当工作时的默认状态
		taskFinished = false;
	}

	public double getHour() {
		return hour;
	}

	public void setHour(double hour) {
		this.hour = hour;
	}

	public State getState() {
		return state;
	}

	public void setState(State state) {
		this.state = state;
	}

	public boolean isTaskFinished() {
		return taskFinished;
	}

	public void setTaskFinished(boolean taskFinished) {
		this.taskFinished = taskFinished;
	}

	// 提供一个方法，用于调用当前状态类的行为
	public void writeProgram() {
		state.writeProgram(this);
	}
}

//抽象状态类
public abstract  class State {
	//该状态执行的行为(跟工作有关)
	public abstract void writeProgram(Work work);
}

//上午状态类
public class ForenoonState extends State{

	@Override
	public void writeProgram(Work work) {
		double hour = work.getHour();
		if (hour<12) {
			System.out.println("当前时间"+hour+"上午精神好");
		}else {
			//设置下一个状态
			work.setState(new AfternoonState());
			//进入下一个状态判断
			work.writeProgram();
		}
	}
}

//下午状态类
public class AfternoonState extends State {

	@Override
	public void writeProgram(Work work) {
		double hour = work.getHour();
		if (hour < 17) {
			System.out.println("当前时间" + hour + "上午精神好");
		} else {
			// 进入下一个状态判断
			work.setState(new EveningState());
			work.writeProgram();
		}
	}
}

//晚上状态类
public class EveningState extends State{

	@Override
	public void writeProgram(Work work) {
		double hour = work.getHour();
		//此时判断是否可以正常下班
		if (work.isTaskFinished()) {
			System.out.println("任务完成回家休息");
		}else if(hour<22){
			System.out.println("当前时间"+hour+"晚上精神差");
		}else {
			//进入下一个状态判断
			work.setState(new SleepingState());
			work.writeProgram();
		}
	}
}

//睡觉状态类
public class SleepingState extends State{

	@Override
	public void writeProgram(Work work) {
		System.out.println("当前时间"+work.getHour()+"不行了睡觉了");
	}
}

public class StateMain {

	public static void main(String[] args) {
		Work work = new Work();
		work.setHour(10);
		work.writeProgram();
		
		work.setHour(20);
		work.writeProgram();
		
		work.setTaskFinished(true);
		work.writeProgram();
	}
}
```

## 13、适配器模式：

目的：将一个接口类型转化为另一个接口类型，从而实现不同类的代码复用。这种方式是为了，在无法改变原有接口设计和代码的情况下，实现不同类型接口的代码复用；因此在接口设计初期应该避免使用该模式

例子：中国球员在国外打球

```java
//抽象球员类
public abstract class Player {
	protected String name;

	public Player(String name) {
		this.name = name;
	}

	// 进攻
	public abstract void attack();

	// 防守
	public abstract void defense();
}

//中锋类
public class Center extends Player {

	public Center(String name) {
		super(name);
	}

	@Override
	public void attack() {
		System.out.println("中锋" + super.name + "发起进攻");
	}

	@Override
	public void defense() {
		System.out.println("中锋" + super.name + "进行防御");
	}
}

//前锋类
public class Forward extends Player{

	public Forward(String name) {
		super(name);
	}

	@Override
	public void attack() {
		System.out.println("前锋" + super.name + "发起进攻");
	}

	@Override
	public void defense() {
		System.out.println("前锋" + super.name + "进行防御");
	}
}

//外籍中锋类（不同接口，但有可以复用方法）
public class ForeignCenter {

	private String name;
	
	public  void  chongChongChong() {
		System.out.println("外籍中锋"+name+"进攻");
	}

	public void huiLai() {
		System.out.println("外籍中锋"+name+"防守");
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}	
}

//外籍中锋的适配器类（适配球员类）
public class Translator extends Player {
	
	private ForeignCenter center = new ForeignCenter();

	//将适配类的name传值给外籍中锋类
	public Translator(String name) {
		super(name);
		center.setName(super.name);
	}

	@Override
	public void attack() {
		center.chongChongChong();
	}

	@Override
	public void defense() {
		center.huiLai();
	}
}

public class AdapterMain {

	public static void main(String[] args) {
		//正常球员
		Player player = new Forward("kope");
		player.attack();
		
		//外籍人员适配器类（这属于一对一的类适配，还可以进行所有该类型的对象适配）
		player=new Translator("姚明");
		player.attack();
		player.defense();
	}
}
```

## 19、备忘录模式:

目的：在不破坏封闭性的前提下，捕捉一个对象内部状态(成员变量值)，并进行保存，之后可以将该对象恢复到原先保存状态

例子：游戏进度备份

```java
//游戏角色类
public class GamePalyer {

	// 当前游戏角色属性
	private int hp;
	private int mp;
	private int lever;

	public void showState() {
		System.out.println("生命：" + hp);
		System.out.println("魔法：" + mp);
		System.out.println("等级：" + lever);
	}

	// 存档（保存游戏角色属性）
	public RoleStateMemento saveRole() {
		return new RoleStateMemento(hp, mp, lever);
	}

	// 恢复存档（游戏角色属性还原）
	public void RecoveryState(RoleStateMemento m) {
		this.hp = m.getHp();
		this.mp = m.getMp();
		this.lever = m.getLever();
	}

	public GamePalyer(int hp, int mp, int lever) {
		this.hp = hp;
		this.mp = mp;
		this.lever = lever;
	}
     。。。所有属性get、set方法
}

//角色状态备份类
public class RoleStateMemento {

	private int hp;
	private int mp;
	private int lever;

	public RoleStateMemento(int hp, int mp, int lever) {
		this.hp = hp;
		this.mp = mp;
		this.lever = lever;
	}
    。。。所有属性get、set方法
}

/备份管理类
public class RoleStateCaretaker {

	//管理三个备份类（允许备份三个）
	private RoleStateMemento m1;
	private RoleStateMemento m2;
	private RoleStateMemento m3;
	public RoleStateMemento getM1() {
		return m1;
	}
	public void setM1(RoleStateMemento m1) {
		this.m1 = m1;
	}
	public RoleStateMemento getM2() {
		return m2;
	}
	public void setM2(RoleStateMemento m2) {
		this.m2 = m2;
	}
	public RoleStateMemento getM3() {
		return m3;
	}
	public void setM3(RoleStateMemento m3) {
		this.m3 = m3;
	}
}

public class MementoMain {
	
	public static void main(String[] args) {
		//创建游戏角色，设置当前状态
		GamePalyer gamePalyer = new GamePalyer(100,100,1);
		gamePalyer.showState();
		
		//创建备份管理类(保存当前游戏角色的存档)
		RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
		roleStateCaretaker.setM1(gamePalyer.saveRole());
		
		//打怪升级
		gamePalyer.setHp(80);
		gamePalyer.setMp(60);
		gamePalyer.setLever(2);
		gamePalyer.showState();
		
	
		//恢复存档
		gamePalyer.RecoveryState(roleStateCaretaker.getM1());
		gamePalyer.showState();
	}
}
```

## 15、组合模式：

目的：将对象组合成树型结构，来表示他们 部分-整体 的层次关系。使得用户可以使用一致的方法来操作单个对象和组合对象

例子：分公司和其下所有部门关系

```java
//公司抽象类
public abstract class Company {

	protected String name;
	
	public Company(String name ) {
		this.name=name;
	}
	
	public abstract void add(Company c);//增加子节点
	public abstract void remove(Company c);//移除子节点
	public abstract void display(int depth);//显示当前节点下的所有分支
	public abstract void work();//执行当前节点工作
}

//具体公司类
public class ConcreteCompany extends Company{
	
	//用于保存所有子节点对象
	private List<Company> children =new ArrayList<Company>();

	public ConcreteCompany(String name) {
		super(name);
	}
	
	@Override
	public void add(Company c) {
		children.add(c);
	}

	@Override
	public void remove(Company c) {
		children.remove(c);
	}

	@Override
	public void display(int depth) {
		String prefix="-";
		if (depth>1) {
			for (int i = 0; i < depth-1; i++) {
				prefix+="-";
			}
		}
		System.out.println(prefix+name);
		for (Company company : children) {
			company.display(depth+2);
		}
	}

	@Override
	public void work() {
		for (Company company : children) {
			company.work();//执行公司下所有部门工作
		}
	}
}

//HR部门
public class HRDepartment extends Company{

	public HRDepartment(String name) {
		super(name);
	}

	//由于部门属于最底层，因此没有子节点，即字节添加、移除为空方法
	@Override
	public void add(Company c) {
	}

	@Override
	public void remove(Company c) {
	}

	@Override
	public void display(int depth) {
		String prefix="-";
		if (depth>1) {
			for (int i = 0; i < depth-1; i++) {
				prefix+="-";
			}
		}
		System.out.println(prefix+name);
	}

	@Override
	public void work() {
		System.out.println(name+"进行员工招聘");
	}
}

//财务部门
public class FinanceDepartment extends Company {

	public FinanceDepartment(String name) {
		super(name);
	}

	// 由于部门属于最底层，因此没有子节点，即字节添加、移除为空方法
	@Override
	public void add(Company c) {
	}

	@Override
	public void remove(Company c) {
	}

	@Override
	public void display(int depth) {
		String prefix = "-";
		if (depth > 1) {
			for (int i = 0; i < depth - 1; i++) {
				prefix += "-";
			}
		}
		System.out.println(prefix + name);
	}

	@Override
	public void work() {
		System.out.println(name+"进行财务收支管理");
	}
}

public class GroupMain {
	public static void main(String[] args) {
		ConcreteCompany root = new ConcreteCompany("北京总公司");
		root.add(new HRDepartment("总公司人力资源部"));
		root.add(new FinanceDepartment("总公司财务部"));
		
		//树型结构图
		root.display(1);
		//执行所有节点的work
		root.work();
	}
}
```

使用场景：适合具有部分-整体关系结构（树型结构）的这部分类的设计，从而实现简单的管理与调用，并且可以手动添加各个节点来扩展该组合对象的功能

缺点：违背了依赖倒转原则，接口只是负责树型结构的创建；节点部分实际功能都是直接在子类中声明，因此不能向上转型，面向接口进行编程

## 16、迭代器模式：

迭代器模式，目前已经使用在java语言中，即迭代器和foreach语法

目的：方便对容器对象（集合）进行一定顺序的遍历，并且不需要暴露器容器中的对象类型和容器的大小

```java
//迭代器接口
public interface Iterator {

	public Object first();//容器第一个元素

	public Object next();//下一个元素

	public boolean isDone();//是否全部遍历（是否存在下一个元素）

	public Object currentItem();//获取当取元素
}

//容器抽象类
public abstract class Aggregate {

	public abstract Iterator createIterator();
}

//具体容器类
public class ConcreteAggregate extends Aggregate{
	
	//内部使用List来进行对象保存
	private List<Object> items = new ArrayList<Object>();

	public int count = items.size();
	
	@Override
	public Iterator createIterator() {
		return new ConcreteIterator(this);
	}
	
	public Object get(int index) {
		return items.get(index);
	}	

	public void add(Object o) {
		items.add(o);
		count=items.size();
	}
}

//具体迭代器类
public class ConcreteIterator implements Iterator {

	// 该迭代器操作的容器类
	private ConcreteAggregate aggregate;

	// 当前遍历到的索引
	private int current = 0;

	public ConcreteIterator(ConcreteAggregate aggregate) {
		this.aggregate = aggregate;
	}

	@Override
	public Object first() {
		return aggregate.get(0);
	}

	@Override
	public Object next() {
		Object ret = null;
		current++;// 索引+1
		// 当前索引没有超出容器最大值，则返回容器当前索引保存的对象
		if (current < aggregate.count) {
			ret = aggregate.get(current);
		}
		return ret;
	}
}

public class IteratorMain {

	public static  void main(String[] args) {

		ConcreteAggregate concreteAggregate = new ConcreteAggregate();
		concreteAggregate.add("1");
		concreteAggregate.add("2");
		concreteAggregate.add("3");
		concreteAggregate.add("4");
		
		ConcreteIterator concreteIterator = new ConcreteIterator(concreteAggregate);
		
		while (!concreteIterator.isDone()) {
			System.out.println(concreteIterator.currentItem());
			concreteIterator.next();
		}
	}
}
```

## 17、单例模式：

目的：保证一个类仅有一个实例，并提供要给单独访问它的全局访问入口

常见单例模式有：懒汉式、饿汉式

```java
//懒加载的单例类（由于类的实例化是在方法调用时完成，因此线程不安全）
public class Singleton {
	
	private static Singleton instance;
	
	//定义唯一的私有构造方法，即该类只能在内部实例化
	private Singleton() {
	}
	
	//提供一个静态方法，来获取内部的静态实例
	public static Singleton getInstance() {
		//延迟加载（懒加载），当该方法被调用时，进行实例化
		if (instance==null) {
			instance=new Singleton();
		}
		return instance;
	}
}

//线程安全的懒加载单例类
public class ThreadSafeSingleton {

	private static ThreadSafeSingleton instance;

	private ThreadSafeSingleton() {
	}

	public static ThreadSafeSingleton getInstance() {
		// 第一次判断，为了当实例被创建时，减少不必要的加锁处理
		if (instance == null) {
			synchronized (ThreadSafeSingleton.class) {//由于是静态方法，所以不能使用this作为对象锁；而变量instance可能为null，所以也不能使用instance变量作为对象锁，因此只能使用类锁
				// 第二次判断，防止同一时间两个线程都通过第一个判断，在其中一线程创建实例后，后一个线程还继续创建实例
				if (instance == null) {
					instance = new ThreadSafeSingleton();
				}
			}
		}

		return instance;
	}
}

//饿汉单例模式（由于静态成员变量在初始化时，是线程安全的；因此不存在）
public class SafeSingleton {

	//在静态初始化时完成创建实例（默认是线程安全的）
	private static SafeSingleton instance= new SafeSingleton();
	
	private SafeSingleton() {
	}
	
	public static SafeSingleton getInstance() {
		return instance;
	}
}
```

两种单例模式的选择：

懒汉模式，懒加载提供资源利用率；由于线程不安全，因此需要进行双重锁定的同步处理，降低实例访问效率（当实例消耗大时，影响更大）

饿汉模式，由JVM装载类时进行静态初始化，保证线程安全，实现简单，实例访问效率高；但是提前创建实例会白白占用内存，降低资源利用率

**综上所述，当实例资源占用不是非常大时，推荐使用饿汉模式**

**补充：**通过静态内部类，在使用JVM初始化保证线程安全的前提下，也可实现懒加载；将创建实例定义到其静态内部类中（静态内部类可以调用外部类的静态成员和方法），然后在getInstance（）中调用内部类的静态成员变量，并返回（即此时初始化该内部类静态成员，获取唯一实例）

## 18、桥接模式：

目的：**将抽象部分和它的实现部分分离，是他们都可以独立的变化**

以手机运行软件为例，手机的实现是运行软件，但手机的品牌是抽象的、软件类型也是抽象的；因此就需要将手机品牌和运行软件分离、软件类型和运行软件分离，此时手机品牌和软件类型就可以独立变化

```java
//手机软件抽象类
public abstract class HandsetSoft {
	public abstract void run();
}

//手机游戏
public class HandsetGame extends HandsetSoft{

	@Override
	public void run() {
		System.out.println("运行手机游戏");
	}
}

//手机通讯录
public class HandsetAddressList extends HandsetSoft {

	@Override
	public void run() {
		System.out.println("运行手机通讯录");
	}
}

//手机品牌
public abstract class HandsetBrand {

	// 手机软件作为其成员变量
	protected HandsetSoft soft;

	// 设置手机运行的软件类型
	public void setSoft(HandsetSoft soft) {
		this.soft = soft;
	}

	public abstract void run();
}

//手机品牌N
public class HandsetBrandN extends HandsetBrand{

	@Override
	public void run() {
		System.out.println("手机品牌为N");
		soft.run();//运行指定的软件
	}
}

//手机品牌M
public class HandsetBrandM extends HandsetBrand{

	@Override
	public void run() {
		System.out.println("手机品牌为M");
		soft.run();//运行指定的软件
	}
}

public class HandsetMain {

	public static void main(String[] args) {
		HandsetBrandN handsetBrandN = new HandsetBrandN();

		handsetBrandN.setSoft(new HandsetGame());
		handsetBrandN.run();

		handsetBrandN.setSoft(new HandsetAddressList());
		handsetBrandN.run();

	}
}
```

桥接模式实际场景：

当一个具体类，需要由两种或以上进行抽象定义；常用的抽象继承，一对多的形式，会形成多层抽象类，大大增加了代码维护和功能扩展的难度；因此我们需要改变这种一对多的形式；而是将所有抽象都作为成员变量放在类中，然后通过它们的具体实现（所有抽象的实现类）来影响最终的行为（目标具体类的方法）

**即，整体构成由图一转变为图二**

![](C:\Users\OneMTime\Desktop\Typora图片\继承和桥接模式的图形解析.png)





![](C:\Users\OneMTime\Desktop\Typora图片\继承和桥接模式的图形解析2.jpg)

## 19、命令模式：

目的：将一个请求封装为一个对象（命令类），从而通过不同的实现类来对应不同请求行为；并且通过对类的操作，实现请求排队、请求日志、请求撤销；不同请求不再通过类中的方法来表示，而是通过不同的命令类，增加请求的可操作性

```java
//命令执行类
public class Barbecuer {

	// 烤羊肉
	public void bakeMutton() {
		System.out.println("烤羊肉串");
	}

	// 烤鸡翅
	public void bakeChickenWing() {
		System.out.println("烤鸡翅");
	}
}

//抽象命令类
public abstract class Command {

	//命令执行者
	protected Barbecuer receiver;
    
    
	
	public Command(Barbecuer receiver) {
		this.receiver=receiver;
	}
	
	//执行命令
	public abstract void excuteCommand();
}

//烤羊肉串命令类
public class BakeMuttonCommand extends Command{

	public BakeMuttonCommand(Barbecuer receiver) {
		super(receiver);
		
	}

	@Override
	public void excuteCommand() {
		receiver.bakeMutton();
	}
}

//烤鸡翅命令类
public class BakeChickenWingCommand extends Command{

	public BakeChickenWingCommand(Barbecuer receiver) {
		super(receiver);
		
	}   
	@Override
	public void excuteCommand() {
		receiver.bakeChickenWing();
	}
}

//服务类（操作命令类）
public class Waiter {
	
	//命令列表（定义命令队列）
	private List<Command> orders =new ArrayList<Command>();

	//设置订单（添加命令）
	public void setOrder(Command command) {
		//此方法可以对命令进行处理、判断；实现命令日志记录、命令是否能执行的操作
		orders.add(command);
	}
	
	//取消命令
	public void cancelOrder(Command command) {
		//将指定命令从命令队列中移除，实现命令撤销,并进行日志记录
		orders.remove(command);
	}
	
	//按顺序执行所有命令队列中的命令
	public void Notify() {
		for (Command command : orders) {
			command.excuteCommand();
		}
	}	
}

public class CommandMain {
	public static void main(String[] args) {
		//初始化命令执行人（执行命令对应的行为）、命令管理人(对命令进行操作)
		Barbecuer barbecuer = new Barbecuer();
		Waiter waiter = new Waiter();
		
		//用户点菜
		waiter.setOrder(new BakeChickenWingCommand(barbecuer));//鸡翅
		waiter.setOrder(new BakeMuttonCommand(barbecuer));//烤肉
		
		//按顺序执行所有命令
		waiter.Notify();
	}
}
```

优点：将发出请求的对象和执行请求对象进行解耦，让他们通过命令对象进行沟通；因此可以实现请求的日志记录、撤销和执行者是否可以完成请求 的处理

## 20、职责链模式：

目的：当有多个对象都有可能接收处理一个请求时，可以使用该模式，将这些对象连接成一条链，请求沿着这条链进行传递，直到找到适合处理该请求的对象；这样就避免了请求发送者和接收者耦合在一起

```java
//请求类
public class Request {

	// 请求类型
	private String requestType;

	// 请求内容
	private String requestContent;

	// 请求等级
	private int number;

	public String getRequestType() {
		return requestType;
	}

	public void setRequestType(String requestType) {
		this.requestType = requestType;
	}

	public String getRequestContent() {
		return requestContent;
	}

	public void setRequestContent(String requestContent) {
		this.requestContent = requestContent;
	}

	public int getNumber() {
		return number;
	}

	public void setNumber(int number) {
		this.number = number;
	}
}

//请求处理抽象类
public abstract class Manager {

	protected String name;

	// 上级
	protected Manager superior;

	public Manager(String name) {
		this.name = name;
	}

	public void setSuperior(Manager superior) {
		this.superior = superior;
	}

	// 处理请求
	public abstract void requestApplication(Request request);
}

//具体处理类A
public class ManagerA extends Manager {

	public ManagerA(String name) {
		super(name);
	}

	@Override
	public void requestApplication(Request request) {
		if (request.getRequestType().equals("请假") && request.getNumber() <= 2) {
			System.out.println("A批准");
		} else {
			if (superior != null) {
				superior.requestApplication(request);
			} else {
				System.out.println("没有可以处理该请求的管理员");
			}
		}
	}
}

//请求处理类B
public class ManagerB extends Manager {

	public ManagerB(String name) {
		super(name);

	}

	@Override
	public void requestApplication(Request request) {
		if (request.getRequestType().equals("请假") && request.getNumber() > 2) {
			System.out.println("B批准");
		} else {
			if (superior != null) {
				superior.requestApplication(request);
			} else {
				System.out.println("没有可以处理该请求的管理员");
			}
		}
	}

}

public class ManagerMain {

	public static void main(String[] args) {
		//创建所有可能的请求接收者
		ManagerA managerA = new ManagerA("A级");
		ManagerB managerB = new ManagerB("B级");
		
		//创建请求
		Request request = new Request();
		request.setNumber(3);
		request.setRequestType("请假1");
		request.setRequestContent("生病，休息两天");
		
		//设置职责链
		managerA.setSuperior(managerB);
		
		//从职责链最底层接收者开始处理
		managerA.requestApplication(request);
	}
}
```

实际应用：sevlet过滤器

优点：1、实现了请求发送者和接送者的耦合

​			2、可以对职责链动态添加、删除、指定顺序；灵活实现对请求的处理

​			3、每个职责类之间没有耦合，创建简单

从形式上，我们可以看到状态模式和职责链模式很像；

相同点：多个类处理同一个问题，进行跳转

不同点：状态模式中，多个状态类之间的跳转是固定的，目的是为了通过多个类，分散状态分支的判断处理职责；而职责链模式是根据客户端代码动态改变的，每个职责类单一不彼此依赖，目的是实现多个对象都有可能接收处理一个请求的问题

## 21、中介者模式：

目的：通过中介者类来封装多个类之间的交互，从而降低这些类直接的耦合，是他们之间不再彼此联系，方便修改

例子：同事之间相互交流：

```java
//抽象中介者类
public abstract class Mediator {
	//
	public abstract void send(String message,Colleague colleague);
}

//抽象同事类
public abstract class Colleague {

	//中介者
	protected Mediator mediator;
	
	public Colleague(Mediator mediator) {
		this.mediator=mediator;
	}
	
	//发送消息
	public abstract void send(String message);
	
	//处理接收消息
	public abstract void accept(String message);
}

//具体中介者类
public class ConcreteMediator extends Mediator {

	// 中介者帮助互相访问的两个对象
	private ConcreteColleague1 c1;
	private ConcreteColleague2 c2;

	//提供两个同事类的set方法
	public void setC1(ConcreteColleague1 c1) {
		this.c1 = c1;
	}

	public void setC2(ConcreteColleague2 c2) {
		this.c2 = c2;
	}

	@Override
	public void send(String message, Colleague colleague) {
		//当其中一个对象发送消息时，则使用另一个对象进行接收
		if (colleague==c1) {
			c2.accept(message);
		}else {
			c1.accept(message);
		}
	}
}


//具体同事类1
public class ConcreteColleague1 extends Colleague {

	public ConcreteColleague1(Mediator mediator) {
		super(mediator);
	}

	@Override
	public void send(String message) {
		// 通过中介者对象发送消息
		mediator.send(message, this);
	}

	@Override
	public void accept(String message) {
		System.out.println("同事1得到消息：" + message);
	}
}

//具体同事类2
public class ConcreteColleague2 extends Colleague{

	public ConcreteColleague2(Mediator mediator) {
		super(mediator);
	}

	@Override
	public void send(String message) {
		//通过中介者对象发送消息
		mediator.send(message, this);
	}

	@Override
	public void accept(String message) {
		System.out.println("同事2得到消息："+message);
	}
}

public class MediatorMain {
	public static void main(String[] args) {
		//创建中介者对象
		ConcreteMediator m = new ConcreteMediator();
		//通过中介者对象，创建需要中介访问的两个对象
		ConcreteColleague1 c1 = new ConcreteColleague1(m);
		ConcreteColleague2 c2 = new ConcreteColleague2(m);
		
		//将两个对象交给中介者管理
		m.setC1(c1);
		m.setC2(c2);
		
		//此时，其中一方进行消息发送后，中介者对象会自动调用另一方执行消息接收
		c1.send("还好吗");
		c2.send("怎么说");
	}
}
```

应用场景：

当多个对象彼此相互交互，耦合度过高时

优点：

1、降低对象之间的耦合，从而实现对象代码能独立复用

2、将多个对象之间的交互统一封装到中介者类中，这样能使系统更好集中维护s

缺点：

1、中介者承担责任过多，代码逻辑过于复杂，导致不好维护

## 22、享元模式：

目的：重用对象，减少创建对象的数量，从而减少内存占用和提高性能；一般重用对象都使内部状态很小地对象，因此也称之为细粒度对象

例子：用同一个对象画圆

```java
//画图的抽象类
public abstract class Shape {

	//画图方法
	public abstract void draw();
}

//画圆实现类
public class Circle extends Shape{
	
	//画圆对象的外部属性
	private int x;
	private int y;
	
	//画圆对象的内部属性（固定）
	private String color;

	@Override
	public void draw() {
		System.out.println("在坐标 "+x+","+y+"上，画一个"+color+"颜色的圆");
	}

	public int getX() {
		return x;
	}

	public void setX(int x) {
		this.x = x;
	}

	public int getY() {
		return y;
	}

	public void setY(int y) {
		this.y = y;
	}

	public String getColor() {
		return color;
	}

	public void setColor(String color) {
		this.color = color;
	}
}

//画图对象工厂
public class CircleFactory {
	//用于存储所有画圆对象
	private HashMap<String, Circle> hashMap=new HashMap<String, Circle>();
	
	//获取固定颜色的画圆对象
	public Circle getCircle(String color) {
		Circle circle = hashMap.get(color);
		if (circle==null) {
			circle = new Circle();
			circle.setColor(color);
			hashMap.put(color, circle);
		}
		return circle;
	}
}

public class CircleMain {

	public static void main(String[] args) {
		CircleFactory circleFactory = new CircleFactory();
		Circle circle = circleFactory.getCircle("白色");
		circle.setX(111);
		circle.setY(22);
		circle.draw();
		
		Circle circle1 = circleFactory.getCircle("白色");
		circle1.setX(11);
		circle1.setY(22);
		circle.draw();
		
 		System.out.println(circle1.hashCode());
 		System.out.println(circle.hashCode());
	}
}
```

实际应用：java中的对象池、数据库连接池

应用场景：系统中使用大量该对象，并且对象资源消耗大；该对象可以通过属性的外部化来实现对象的重用时的多状态变化

## 23、解释器模式：

目的：对于某个特定类型问题（对某种语言进行解析），发生频率只够高时，可以通过构建一个解释器，来专门解决该问题

实际应用：用于sql解析、正则表达式匹配

## 24、访问者模式：

目的：将数据结构和算法操作分离，使得算法操作的新增变得容易

应用场景：数据结构相对稳定，但算法易于变换；

例子：在不同状态下，男女的反应

```java
//状态抽象类（访问者类）
public abstract class Action {

	//不同条件下，访问结果
	public abstract void getManConclusion(Man man);
	
	public abstract void getWomanConclusion(Woman woman);
}

//状态实现类（定义类该类在访问不同对象时，所有对应执行的方法）
public class Success extends Action{

	private String type="成功";
	
	@Override
	public void getManConclusion(Man man) {
		System.out.println("在"+man.getName()+type+"时，背后多半有一个伟大的女人");
	}

	@Override
	public void getWomanConclusion(Woman woman) {
		System.out.println("在"+woman.getName()+type+"时，背后多半有一个不成功的男人");
	}

}

public class Failing extends Action{
	
	private String type="失败";

	@Override
	public void getManConclusion(Man man) {
		System.out.println("在"+man.getName()+type+"时，只会闷头喝酒");
	}

	@Override
	public void getWomanConclusion(Woman woman) {
		System.out.println("在"+woman.getName()+type+"时，只会两眼汪汪");
	}

}

//抽象被访问者类
public abstract class person {

	//进行访问，并获取状态(参数为访问者)
	public abstract void accept(Action visitor);
}

//被访问者实现类
public class Man extends person{
	
	private String name;
	
	public Man(String name) {
		this.name=name;
	}
	
	public String getName() {
		return name;
	}

	@Override
	public void accept(Action visitor) {
		visitor.getManConclusion(this);
	}
}

public class Woman extends person {

	private String name;
	
	public Woman(String name) {
		this.name=name;
	}
	
	public String getName() {
		return name;
	}
	
	@Override
	public void accept(Action visitor) {
		visitor.getWomanConclusion(this);
	}
}

public class VisitorMain {

	public static void main(String[] args) {
		Failing failing = new Failing();
		Man man = new Man("yh");
		man.accept(failing);
	}
}
```

可以看到，访问者模式可以很方便的实现：通过多个访问者类，来避免了对访问者类型的判断，每个方法对于相应类型的行为处理，提高了代码的可扩展性；

缺点：违反了迪米特法则，访问者中会之间调用具体被访问者的访问，而不是面向接口；此时修改被访者代码的成本大大增加

**一般情况下，该设计模式不需要使用**

# 设计模式总结：

1、面向对象和面向过程的区别：

面向过程：把需求理解成一条条的业务流程，然后将所有流程组合划分成一个个功能模块，对应成相应的代码函数；

面向过程关注于业务流程，因此当业务发生改变时，会极大的影响代码的修改，并难以维护；这样大大增加了开发效率，并无法面对实际开发过程中的需求变更

面向对象：将需求理解为一个个事物对象，每个对象都定义了自己复杂的事物（我是谁、我从哪里来、我能做什么）；通过对象将容易发生改变的代码封装起来，从而在实现代码复用的同时，极大的降低的代码之间的耦合

2、设计模式的产生：

由于面向对象编程的高灵活性，在面对一些复杂业务时，往往需要一些更灵活、复用的设计方案来面向对象编程；因此通过前人的总结实践，提出了这些公认的设计模式（面向对象的编程方案）

3、创建性模式：通过模式，定义了类的创建规则或过程，并将其封装隐藏

- 抽象工厂模式：定义一个用于创建 一系列或相关依赖对象的接口，每个实现类对应一组对象的创建

- 建造者模式：将一个复杂对象的创建过程与它的表示（初始化行为）分离，在固定的建造流程中，通过改变每个流程节点（具体创建者类中的方法）；实现复杂对象的多种初始化需求

- 工厂方法模式：定义一个用于创建对象的接口，每个实现类对应一个对象的创建

- 原型模式：通过对原型类的改造，实现其自身拷贝创建新对象

- 单例模式：保证类只能有一个实例，并提供对该实例的安全访问

4、结构型模式：处理类或对象之间的结构关系；分为对象结构型模式和类结构型模式；类结构型模式是使用继承设计类之间的结构；对象结构模式是通过组合或聚合来设计类之间的结构；

- 适配器模式：将一个类的接口转化为客户希望的另一个接口，使原本接口不兼容而不能一个工作的类，可以一起工作

- 桥接模式：将抽象部分与它实现部分分离，使得它们两者都能够独立变化；利用组合替代继承，更好地解决了类多维度抽象定义地问题
- 组合模式：将对象组合成树型结构，来表示它们 部分-整体的层次关系；使用户对单个对象和组合对象的使用保持一致性
- 装饰模式：动态地给一个对象添加额外职责；相对于继承更加灵活、动态透明

- 外观模式：为子系统提供一个高层接口，以系统功能使用为出发点，简化客户端对子系统地使用，从而内部隐藏子系统一系列接口地复杂调用

- 享元模式：通过运用共享技术，实现大量细粒度对象（内部状态较少的对象）的重用
- 代理模式：通过提供目标对象的代理类，来实现对目标对象的额外功能扩展或访问控制

5、行为型模式：用于定义类或对象间的交互和职责分配

- 观察者模式：也叫发布-订阅模式，定义了对象间一对多的关系；当一个对象状态发生改变时，会通知所有依赖于它的对象
- 模板方法模式：在定义某些算法（行为）时，可以先定义算法骨架（抽象接口），将具体实现步骤延迟到子类中；从而可以更快在不改变原有算法的基础上，重定义该算法的某些特定步骤

- 命令模式：将请求封装为一个对象；从而将请求与执行请求进行解耦，实现请求的排队、日记记录和撤销操作
- 状态模式：将代码责任分解，在复杂的分支逻辑中，每一个分支状态对应一个状态类，从而面向对象编程；减轻了单个类的职责，并能对分支状态变化进行更好的重构

- 职责链模式：将请求的发送者和接收者进行解耦，将请求依次交给所有处理对象，通过判断是否能处理请求；这样即保证了请求能够合理的找到接收者，同时也更好的解决了所有接收者处理请求的优先级关系

- 解释器模式：通过简单语言来表述一种多发问题，并提供一个解释器进行解释
- 中介者模式：通过中介者对象来封装一系列对象的交互，使它们耦合降低，从而能够独立的改变他们的交互行为（满足最小知识原则，极大的降低类之间的耦合，利于代码复用）
- 访问者模式：将访问者的状态和对应访问行为分离；每一个具体访问者实现具体的操作，在不改变各被访问者对象的情况下，新增不同访问状态时的行为（满足开闭原则进行新增）
- 备忘录模式：在不破坏类的封装性的前提下，对类中的原有属性进行备份，并实现其回滚功能
- 迭代器模式：提供一个可以按顺序访问容器对象中的所有元素方法，并不暴露该容器对象的类型和大小