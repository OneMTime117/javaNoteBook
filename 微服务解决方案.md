# 微服务解决方案

## 1、eureka

## 2、system

### 1、规范包名、类名、模块

### 2、springboot(2.3.5v)：

#### webConfig

##### 1、服务器端口、应用名、数据库配置：

**springboot2.x默认使用HikariCP连接池**

```yaml
server:
  port: 8001
spring:
  application:
    name: system
	datasource:
    	url: jdbc:mysql://47.111.141.110:3306/myProject?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT
   		username: root
    	password: 123456
    	driver-class-name: com.mysql.cj.jdbc.Driver
```

##### 2、mybatis-mapper扫描注入、开启@Transactional注解、springboot自动配置注解：

```java
@SpringBootApplication
@MapperScan(basePackages = {"com.yh.system.mapper"})
@EnableTransactionManagement
public class SystemApplication {
```

##### 3、请求响应对象封装:

```java
public class Result {

	private Object data;
	private Integer code;
	private String msg = "";

	public static Result ok() {
		Result result = new Result();
		result.code = HttpStatus.OK.value();//200
		return result;
	}

	public static Result ok(Object data) {
		Result result = new Result();
		result.code = HttpStatus.OK.value();//200
		result.data = data;
		return result;
	}

	public static Result error() {
		Result result = new Result();
		result.code = HttpStatus.INTERNAL_SERVER_ERROR.value();//500
		return result;
	}

	public static Result error(String msg) {
		Result result = new Result();
		result.code = HttpStatus.INTERNAL_SERVER_ERROR.value();//500
		result.msg = msg;
		return result;
	}
}
```

##### 4、全局异常处理器配置：

```java
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {
}
```

##### 5、全局请求入参格式化处理（时间格式化）：

请求入参数据处理分为两种：

###### 1、form表单和url传参：

**springBoot2.x默认情况下，不会对时间类型进行处理**

存在两种处理方法：

1、自定义参数转换器

springBoot在接受form表单和url传参数据时，会统一进行参数转换处理，通过自定义参数转化器，对指定参数进行自定义的格式处理，将String转换为需要的对象类型

```java
@Configuration
public class DateTimeConverterConfig {

	@Bean
	public Converter<String, Date> DateConverter() {
		return new Converter<String, Date>() {
			@Override
			public Date convert(String source) {
				//使用Hutool-DateUtil工具类，支持多种时间类型的格式化
                //格式化时，使用JVM默认时区，因此date打印数据不变
				return DateUtil.parse(source);
			}
		};
	}

	@Bean
	public Converter<String, LocalDateTime> localDateTimeConverter() {
		return new Converter<String, LocalDateTime>() {
			@Override
			public LocalDateTime convert(String source) {
				return LocalDateTime.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
			}
		};
	}

	@Bean
	public Converter<String, LocalDate> localDateConverter() {
		return new Converter<String, LocalDate>() {
			@Override
			public LocalDate convert(String source) {
				return LocalDate.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
			}
		};
	}

	@Bean
	public Converter<String, LocalTime> localTimeConverter() {
		return new Converter<String, LocalTime>() {
			@Override
			public LocalTime convert(String source) {
				return LocalTime.parse(source, DateTimeFormatter.ofPattern("HH:mm:ss"));
			}
		};
	}
}
```

2、使用@DateTimeFormat注解，由springboot提供，用于指定时间字段的参数转换方式：

```java
@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") 
private Date time
```

**注意：**

**1、@DateTimeFormat注解在设计时，没有时区转换，是用于配合JDK8的时间日期API使用，因此使用Date进行接收时，默认为是当前JVM时区的正确时间**

**2、@DateTimeFormat和自定义参数转换器同时使用时，全局的自定义参数转换器会覆盖@DateTimeFormat**

###### 2、Post请求的JSON入参：

**springBoot2.x默认使用jackson实现json序列化和反序列化**

默认只支持Date类型字段**yyyy-MM-dd** 格式和时间戳格式的进行转换

存在三种处理方式：

1、修改jackson时间序列化格式：

```yaml
spring:  
	jackson:
    	date-format: yyyy-MM-dd HH:mm:ss
```

缺点：只能使用Date类型，不支持JDK8的时间API

2、使用@JsonFormat指定DTO中单个时间类型字段的json序列化和反序列化格式

```java
	@JsonFormat(pattern = "yyyy-MM-dd")
	private LocalDate localDate;

	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	private LocalDateTime localDateTime;

	@JsonFormat(pattern = "HH:mm:ss")
	private LocalTime localTime;

	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	private Date date;
```

优点：支持java所有时间类型，并且对于Date类型可以随意转换为日期、时间、日期+时间

缺点：不是全局设置，比较繁琐

3、自定义MappingJackson2HttpMessageConverter，即Jackson转换器，来配置对应类型的数据序列化、反序列化过程，**会将springBoot默认自动化配置的jsack转换器覆盖，此时springboot配置文件的jackson设置也会失效**

```java
@Configuration
public class JacksonConfig {

	/** 默认日期时间格式 */
	public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
	/** 默认日期格式 */
	public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dMappingJackson2HttpMessageConverterd";
	/** 默认时间格式 */
	public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

	@Bean
	MappingJackson2HttpMessageConverter httpMessageConverter(){
		MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
		ObjectMapper objectMapper = new ObjectMapper();
		//指定date类型的序列化与反序列化处理
		objectMapper.setDateFormat(new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT));

		//支持JDK8的日期时间类型的序列化与反序列化处理
		JavaTimeModule javaTimeModule = new JavaTimeModule();
		javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
		javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
		javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
		javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
		javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
		javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
		objectMapper.registerModule(javaTimeModule);

		converter.setObjectMapper(objectMapper);
		return converter;
	}
}
```

**json格式化时区转化问题：**

- 前两种方式，都是默认使用springBoot配置好的Jackson转化器，其中使用的DateFormat对象，在构建时，会自动设置并使用JVM的时区，因此时间类型数据转换时，会出现如下处理：

  - 获取需要反序列化的时间数据，并默认当前时间为UTC(即 GMT +00:00时区)，因此进行DateFormat格式化处理时，会默认使用CST时间进行展示（GMT +8：00），因此在打印时，时间会+8小时

  - 同理，进行序列化时，时间会-8小时

  **解决方法：**

  - 第一种方式，通过springboot配置文件，设置JackSon转化器全局time-Zone，使其进行时间转换时，默认为当前时间的时区为GMT+8:00

  ```java
  spring:  
  	jackson:
      	time-zone: GMT+8:00
  ```

  - 第二种方式，使用@JsonFormat时，添加timezone属性，本质上和方式一致，但是只针对于@JsonFormat所注解的字段

  ```java
  @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss" ,timezone = "GMT+8")
  private Date date;
  ```

  **注意：如果没有指定，则使用springBoot默认配置的值，包括springBoot的配置文件**

- 第三种方式：

  和方式一同理，已代码的方式在自定义jackson转化器中，直接配置全局的time-zone

  ```java
  //jackson进行时间格式转换时，会默认当前时间为UTC(即 GMT +00:00)
  objectMapper.setTimeZone(TimeZone.getTimeZone("GMT+8:00"));
  ```

  **注意：**

  **1、如果obejctMapper和DateFormat同时指定timeZone时，obejctMapper全局配置的timeZone优先**

  **2、@JsonFormat和自定义Jackson转换器同时使用时，@JsonFormat优先**

**对于LocalDateTime的时间存储：**

​	该对象并不存在时区信息，单纯是对一个日期、时间信息的存储，因此在进行格式化转换过程中，不会存在时区的转换；因此如果单纯使用LocalDateTime进行数据库时间的存储和获取时，需要保证数据库客户端时区与前端需要的时区一致**（因此Jackson对于时区的设置，并不会影响LocalDateTime字段的json解析）**

**如果需要使用带有偏移量/时区的时间：**

​	JDK8，提供OffsetDateTime/ZonedDateTime，来实现带有偏移量和时区的时间处理，从而实现国际化

##### 6、jackson配置和注解

​	前面说到，springBoot对于Body数据的传输，统一使用jackson进行序列化和反序列化

**常用配置：**

```java
//为空时，不进行序列化
objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
```

注意：如果自定义jackson转换器，则springboot的配置属性会失效，因此需要在自定义jackson转换器时，手动以代码形式设置

**常用注解：**

| 注解                  | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| @JsonProperty         | 序列化、反序列化时，java对象属性名映射json的字段名           |
| @JsonIgnore           | 忽略该字段的json处理                                         |
| @JsonIgnoreProperties | 注解在类上，忽略多个字段的json处理                           |
| @JsonInclude          | 注解在字段或类上，定义序列化条件（always、non_default、non_empty、non_null） |
| @JsonFormat           | 时间类型字段的序列化和反序列化的格式转换                     |

httpClient、webSocket、文件上传下载、定时任务、注解Aop

### 3、mybatis-plus（tkmybatis和Pagehelper）

1、单表CRUD方法

2、id自动生成

3、分页插件

### 4、swagger

### 5、Bean Validator

### 6、logback

### 7、redis

### 8、hutool

### 9、lombok

### 10、JUnit4

3、Ribbon、feign

4、Hystrix

5、gateway

6、nacos

7、分布式缓存、分布式锁、分布式任务、分布式事务