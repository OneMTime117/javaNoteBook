# 开发常用

## JDK

### 1、基础数据类型和包装类：

int   整数   字节4个   2的32次方
long   长整数    8个   
short   短整数   2个    范围（2的16次方，即-2的15次方 到  2的15次方-1   -32768----- 32767）
float    单精度浮点型（小数）   4个
double   双精度浮点型 （大范围的小数）  8个
char      字符（单引号，一个字符）      Unicode编码：2个  计算机能表示的字符数0-65535
boolean   布尔型（赋值为真假（turn false）对应的整数赋值为1，0 ；非零代指1）  一个字节  
byte      字节型（-128-127整数）     1个   范围（2的8次方）

定义float时，应在赋值数后加F，系统默认小数为double类型，以声明赋值数满足其float数据类型范围
定义long时，应在赋值数后加L，系统默认整数为int类型
float范围大于long范围
float精度有效位数为7
double 精度有效位数为16

- 基本数据类型的相互转化：

1、自动转化：byte->short->int->long->float->double   char->int

在JAVA中，基本类型（除了boolean外）可以自动转换的；表述范围小的可以自动转换为表述范围大的；当不同基础类型计算时，范围小的会自动转化为范围大的，再进行运算，如：float与double运算时是自动转换为double再进行计算，结果为double类型

2、强制转化：

表述范围大的可以强制转换为表述范围小的，需要对结果进行显示的强制转化，有时会导致丢失精度或数据溢出（获得一个没有意义的数值）

int a=1;
double b =32423;
int c= (int) (a+b);

- 基本数据类型的包装类

Byte、Integer、Character、Short、Long、Float、Double、Boolean

​	**以Integer为例，基础数据和包装类的相互转化：**

1、包装类通过new和valueOf（int a）静态方法的两种方式，实现基础类型向包装类的转化

2、intValue（）：实现包装类转化为基础类型

在JDK1.5后，引入了自动拆装箱的语法，直接可以直接赋值，系统自动进行拆箱和装箱

```java
	int a = 1;
Integer b =2;//装箱
a=b;//拆箱
```

​	**包装类是对基础类型的封装，实际上内部还是操作的基础数据类型：**

​	1、除Character、Boolean外，其他包装类都继承了抽象类Number，实现了内部基础类型自动转化或强制转化为其他基础数据类型的方法：byteValue（）、intValue()......

​	2、对于Character类，则是内部自定义了一个charValue()方法，转化为char类型；然后只能手动强制转化为int（通过ASCII码进行转化）

toUpperCase（char c）、toLowerCase（char c）：静态方法，将指定字符转为大写、小写

isUpperCase（char c）、isLowerCase（char c) :静态方法，判断指定字符是否为大写、小写

​	3、对于Boolean类，有两种构造方式，参数分别为boolean、String；String参数的构造方法，Boolean内部会对参数进行判断，为“true”字符串时，则value为true

   **4、所有包装类都实现了Comparable接口，重写compareTo（）方法，以Character为例：**

compareTo （Character  anotherChar）：将两个字符比较，相同时返回0；不同时返回char-anotherChar的差值（ASCII码的差值）

​	**5、所有包装类都重写了Object类的equals（）方法、toString（）方法；用于比较和展示包装类中内部的基本数类型值**

​	**6、所有包装类都有ValueOf（String s）静态方法，用于将String类型转变为基本数据类型的包装类；所有包装类也都有parseByte（String s）静态方法，用于将String类型转变为基本数据类型**

**所有基础包装类，都是不可变的（无法被继承），即外部无法对类中的成员变量进行修改**

### 2、String类

String类中默认将字符串保存为一个char类型数组，然后进行操作，实现了CharSequence接口，重写如下常用方法：

CharSequence（字符序列）是java字符串的另一种表达形式，可以实现字符串数据类型的读写；String类只能实现字符串的读

1、length（）：获取字符串长度

2、chanrAT（int a）：获取指定下标字符

String实现了Comparable接口，实现了：

3、compareTo（String s）：两个字符串按字符顺序依次比较（ASCII码的差值），直到第一次出现不同，小为负，大为正；所有字符都相同，则返回0

4、重写Object的toString（）、equals（Object obj）、hashCode（）方法；用于比较和展示字符串

5、toUpperCase（）、toLowerCase（）：转换字符串所有字符的大小写

6、indexOf（int char）：查找指定字符第一次出现在字符串中的下标

​      indexOf（int char ，int index）：从下标为index的开始（包含该下标的字符），查找字符第一次出现在字符串的下标

​	  lastIndexOf（int char）：查找指定字符最后一次出现在字符串的下标

7、split（String s）：通过正则表达式，以s来分隔该字符串

8、trim（）：去掉字符串左右空格

9、replace（CharSequence target, CharSequence replacement）:将字符串中所有的target字符串代替为replacement字符串

​	  replaceAll (String regex, String replacement)	：支持对第一个字符串参数进行正则表达式解析，满足replace的方法同时，还可以使用正则表达式进行匹配替换

​	  replaceFirst(String regex, String replacement)：正则表达式进行匹配替换，只替换第一处

10、substring(int beginIndex,int endIndex) 截取字符串，从beginIndex开始（包含当前下标），到endIndex前结束（不包含当前下标字符）

11、contains(String s)：判断是否包含该字符串

12、equalsIgnoreCase(String s)：比较字符串，但忽略大小写

13、startsWith(String）、endsWith(String)：判断字符串是否以指定前缀开始、后缀结束

14、String.format(String,Object...) :静态方法，格式化字符串

### 3、String类的辅助类：StringBuffer、StringBliud

由于String对象是不可变的：即外部无法对类中的成员变量进行修改;String 中只有三个成员变量：value，offset和count，都被private修饰，且没有set方法，因此在操作String类型时，实际上时重新new了一次

大大部分场景中，我们都需要进行大量的String操作，如果使用String，就会产生大量无用的String对象；因此就需要使用可操作的String类：StringBuffer、StringBliud

- **StringBuffer、StringBliud都可以对本身字符串进行操作，常用方法有：**

1、append方法
public StringBuffer append(boolean b)
该方法的作用是追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。

2、deleteCharAt方法
public StringBuffer deleteCharAt(int index)
该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。

3、insert方法
public StringBuffer insert(int offset, String s)
该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。

4、reverse方法
public StringBuffer reverse()
该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。

5、setCharAt方法
public void setCharAt(int index, char ch)
该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。

6、trimToSize方法
public void trimToSize()
该方法的作用是将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费。

7、toString方法

转换为不变字符串（string类型）:变量调用 StringBuff的toString()方法

8、构造方法中可有参数，定义字符缓存区的字节数
StringBuffer s0=new StringBuffer();默认分配了长16字节的字符缓冲区
StringBuffer s1=new StringBuffer(512);分配了512字节的字符缓冲区

- **StringBuffer、StringBliud两者的区别：**

StringBuilder类，用于更效率的对字符串进行操作，线程不安全；

StringBuffuer类，其线程是安全的，因此效率比StringBuilder低一点

- **java默认重载了配合String使用时的操作符“+”和“+=”，执行了StringBuilder的append（）方法，然后转换为String对象**

### 4、基础工具类：

#### 1、数学类Math

math类提供一系列基本数据运算和几何函数的方法，所有成员变量和方法都是静态的，常用有：

1、静态常量：pi  圆周率的double值

2、pow (double a, double b)   a的b次方

3、sqrt（double a） a的平方根

4、abs（int a）a的绝对值，可以是long、float 和 double 类型的参数

5、ceil（double a）返回大于等于a的最小整数的double类型值

6、doouble floor（double a）返回小于等于a的最大整数的double类型值

7、max（int a,int b）、min（int a,int b）获得两者中较大、较小的

8、round（float a）返回四舍五入的整数

**在负数进行四舍五入式，先对其绝对值进行四舍五入，然后在将负数加上**

Math.random() 返回一个[0.0，1.0）之间的double值（内部是使用了Random类）

#### 2、随机数类Random

Random有两个构造方法，默认构造器或传入一个Long类型的随机种子参数

提供除char类型外的七中基本数据类型的随机数，Random的随机数并不是完全随机的（伪随机数），整个随机数序列都和随机种子参数有关，因此两个相同随机种子参数的Random类，产生的随机数序列是相同的

```java
		Random random = new Random();
		double nextDouble = random.nextDouble();//0.0-1.0,不包含1.0
		int nextInt = random.nextInt(1000);//0到1000，不包含1000
```

使用默认构造方法是，也生成了一个随机种子参数：seedUniquifier() ^ System.nanoTime()，进行的大量的运算，理论上不可能有相同数，因此一般使用默认构造方法就可以保证完全随机。只有特殊需求时，才指定随机种子参数

#### 3、正则表达式Pattern、Matcher

#### 4、Object类

Object是java中所有类的超类，即他们类层次结构中的根类；所有类都继承了它

常用方法有：

hashCode（）：获取当前对象的哈希值（一般情况下，不同对象的哈希值是不同的）

getClass（）：获取当前对象的类的Class对象（用于进行反射操作等）

toString（）：将当前对象打印为字符串（默认是打印 该类的全限名+@+哈希值）；大多时候都需要重写

equals（Object obj）:比较两个对象的引用是否相同（两个变量是否指向同一个对象内存地址），和==的作用一样；大多时候都需要重写

wait（）用于在多线程控制中，释放当前对象的使用权，并一直处于阻塞状态，直到被唤醒

notify（）、notifyAll（）：用于在多线程控制中，唤醒执行了改当前对象wait（）方法的线程

finalize（）：用于java垃圾回收机制，告诉垃圾回收器，该对象可以被回收（但是并不能使垃圾回收器一定去销毁该对象）

clone（）：java对象浅拷贝，它会拷贝当前对象，生成一个新的对象，并有一个新的引用，因此两者表面上是不相关的；但是在对象中的引用类型属性变量保存的引用却是指向同一个对象的，**所以在操作该对象中的引用类型属性时，会影响拷贝对象中的属性（由于String类和包装类为final，因此在拷贝后，在修改拷贝对象的String属性时，不会修改引用指向的内存空间的值，而是创建一个新的对象进行引用，因此两者不会相互影响）**

**浅拷贝的使用：**

1、由于clone（）在Object类中是protected的，因此只能在子类内部中使用，无法直接在外面通过类的实例调用；因此需要使用浅拷贝的类，需要使用一个方法提供对内部this.clone的访问

2、clone方法会抛出一个CloneNotSupportedException异常；只有当使用该方法的类实现Cloneable接口时，才不会抛出异常，即就是允许该类执行浅拷贝

**一般不使用浅拷贝，会带来对象使用时不必要的风险，可以通过代码来实现深拷贝，即对象和拷贝对象完全不相关：**

1、使用拷贝工厂，利用反射来实现（更容易使用）

2、添加一个类的构造方法，参数为该类的实例对象，然后通过该构造方法创建新对象时，保证新对象中的所有属性都是新new的，值和参数对象中的一致（需要修改类的本身结构）

3、将对象序列化，然后在反序列化生成一个新对象，这种方式效率很慢，并且所有有关的应用类型都需要实现Serializable接口，保证能够序列化

#### 5、系统类System

System有三个成员变量，in（标准输入流，键盘输入）、out（标准输出流）、err（标准错误输出流）

常用方法有：

exit（int status）:退出程序，0代表正常退出、非0代表异常退出

currentTimeMillis（）：返回当前时间毫秒数

nanoTime() ：返回一个随机时间的纳米级时间数

getProperties（）、getPropertie（String Key）:获取系统属性

arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：复制数组

#### 6、容器工具类Arrays、Collections

**1、Arrays，数组工具类：**

常用方法如下：

| 方法                         | 作用                                                      |
| ---------------------------- | --------------------------------------------------------- |
| Arrays.equals(a1,a2)         | 比较两个基本类型数组是否相同（大小、顺序）                |
| Arrays.deepEquals(a1,a2)     | 比较两个包装类数组是否相同（大小、顺序）                  |
| Arrays.sort(a,Comparator)    | 数组排序，指定比较器（默认字节码大小排序）                |
| Arrays.binarySearch(a,value) | 二分查找法找指定元素的索引值（下标）,数组元素是已经排序的 |
| Arrays.toString()            | 打印数组                                                  |
| Arrays.fill(a，1)            | 用指定值，填充数组                                        |
| Arrays.asList（a）           | 将数组转化为list，不推荐使用，有很多风险                  |
| Arrays.copyOf(a,int)         | 拷贝数组,指定数组长度                                     |
| Arrays.stream(a)             | 获取Stream流                                              |

**2、Collections，集合工具类**

常用方法如下：

| 方法                                  | 作用                                                   |
| ------------------------------------- | ------------------------------------------------------ |
| Collections.sort(c,Comparator)        | List集合排序（可以指定比较器）                         |
| Collections.reverse(c)                | List集合反向排列                                       |
| Collections.fill（c,o）               | 指定对象，填充List集合                                 |
| Collections.copy（c1,c2）             | 拷贝List集合                                           |
| Collections.min(c)/Collections.max(c) | 取Collecttion集合中的最小/最大值（可以指定比较器）     |
| Collections.emptyXXX（）              | 返回一个不可变的空集合对象（实现对象重用）             |
| Collections.SingletonXXX（）          | 返回一个不可变、只有一个元素的集合对象（实现对象重用） |

#### 7、对象工具类Objects、Comparator

**1、Objects，对象工具类**

| 方法                      | 作用                                                         |
| ------------------------- | ------------------------------------------------------------ |
| equals（o1,o2）           | 比较两个对象是否相等；都为null时为true；其中一个为null时为false（可以有效避免使用a.equals(b)出现的空指针异常） |
| deepequals（o1，o2）      | 深度比较两个对象是否相等（如果为数组对象，则调用Arrays.deepequals方法，进行包装类数组的比较） |
| nonNull（o）              | 检测对象是否不为null，不为null返回true                       |
| isNull（o）               | 检测对象是否为null，为null返回true                           |
| toString（o）             | 调用对象的toString方法，为null则返回null字符串               |
| toString（o,nullDefault） | 调用对象的toString方法，为null则返回nullDefault默认字符；就是三元表达式的封装简化 |

**2、Comparator，对象比较器**

**java中，Comparator比较器或Comparable提供的比较方法，其达到的排序效果都是正序（从小到大）**

1、Comparator类提供了多个comparing()方法，以Function（函数式接口）具体实现类为对象，从而实现提取某个类型对象中的一个基本数据类型进行compareTo方法比较（8种基本数据类和String都提供了该方法）的自定义Comparator；**然后可以作用Arrays/Collections的sort方法参数，进行数组、集合容器中的对象排序、或者treeSet、treeMap的构造方法参数，实现它们的排序**

```java
Comparator<Account> comparing = Comparator.comparing(new Function<Account,String>(){
    public String apply(Account a){
        return t.getAccount();
    }
});

//可以使用lambda表达式的方法引用进行简化
Comparator<Account> comparing2 = Comparator.comparing(Account::getAccount);
```

2、直接实例化Comparator对象，实现compareTo方法，来创建指定对象的比较器

```java
Comparator<Account> comparator = new Comparator<Account>() {
	@Override
	public int compare(Account a1, Account a2) {
		return a1.getAccount().compareTo(a2.getAccount());
	}
};
```

3、对于Comparator比较器，提供一个reversed方法，用于反转判断排序（就可以将正序改为倒叙）

```java
Comparator<Account> = reversedcomparator.reversed();
```

### 5、常用容器接口方法：

#### 1、Collection接口常用方法：

| 方法               | 作用                             |
| ------------------ | -------------------------------- |
| add(E e)           | 添加元素                         |
| remove（E e）      | 删除元素                         |
| clear()            | 暴力清除集合中所有元素           |
| contains(Object o) | 判断集合是否包含某个元素         |
| isEmpty()          | 如果此集合不包含元素，则返回true |
| iterator()         | 获取迭代器                       |
| size()             | 集合中的元素数                   |

#### 2、List接口额外常用方法：

| 方法                         | 作用                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| get（int index）             | 获取指定索引位置元素                                         |
| set（int index，Object obj） | 修改指定索引位置元素                                         |
| remove（int index）          | 删除指定索引位置元素                                         |
| listIterator（）             | 获取list增强版迭代器，可以调用set（）、add（）方法，在当前遍历位置替换、插入元素 |

#### 3、Set接口和Collection接口方法完全一样

#### 4、Map常用方法：

| 方法                     | 功能                              |
| ------------------------ | --------------------------------- |
| put（K key，V value）    | 添加键值对                        |
| containsKey（K key）     | map中是否存在该key                |
| containsValue（V value） | map中是否存在该value              |
| get（K key）             | 获取map中key对应value             |
| values（）               | 返回所有value对象的Collection集合 |
| KeySet（）               | 返回所有key对象的set集合          |
| entrySet()               | 获取Entry对象Set集合              |

#### 5、集合遍历方式：

- Collection遍历：

  foreach和itreator的区别：

  - foreach需要知道容器具体类型，且不能使用remove、add方法，但是代码整洁、易懂
  - itreator不用知道容器具体类型，且速度快，且可以遍历删除remove当前元素

- Map遍历：

  - java8下，推荐使用forEach（）方法执行

  ```java
  hashMap.forEach((k,v)-> {System.out.println(k+""+v)});
  ```

  **forEach（）本质上是匿名函数（匿名内部类），它闭包形成当前线程环境（获取外部类的所有变量）后，会使用另一个线程执行，此时局部变量是不能保证没有被销毁的，为了防止该问题的产生，jvm对于final修饰的变量，不会直接在内部类中操作，而是copy一份。因此对于内部类使用外部类局部变量时，一定要添加final，才能通过编译**

  - java8以下版本，推荐entrySet forach遍历

  ```java
  Set<Entry<K, V>> entrySet = hashMap.entrySet();   
  for (Entry<K, V> entry : entrySet) {
  	System.out.println(entry.getkey+""+entry.getValue);
  }
  ```

### 6、日期时间格式化类

#### 1、日期类Date

1、getTime（）：获取当前时间的毫秒数，从1970年开始

2、setTime（Long time）：设置当前date对象的时间毫秒数

3、toString（）：以dow（星期） mon（月份） dd（日） hh:mm:ss zzz（时区） yyyy（年） 格式来展示当前时间

4、after(Date date) ：判断当前时间是否在date之后

​	  before(Date date)：  判断当前时间是否在date之前

​	  equals(Object obj)：  判断当前时间是否于date相等，精确到毫秒

#### 2、日历类Calendar

相对于日期类，Calendar解决了date获取年份需要+1970的问题，并且在对于时间节点的加减上更加灵活，能够简单解决日常开发中获取复杂条件时间的问题，如该月的第一个星期。。。

**1、Calendar实例化使用getInstance（）静态方法获取：**

有多个重载方法，需要传入TimeZone (时区)、 Locale（国家）；无参方法使用系统默认TimeZone(Asia/Shanghai)、Locale（zh_CN）

不同国家和时区，可能会使用不同的日历系统

**2、Calendar常用方法：**

Calendar类提供多个静态成员变量，用于描述日历参数：

年月日、时分秒、毫秒、当月第几天、当周第几天、当月第几个星期、当年第几天、当年第几周

这些参数很好的描述了平常开发中需要的时间

get(int field)，获取当前日历对象的日历参数值

set(int field)，设置当前日历对象的日历参数值

setTime（Date date），将date对象转化为日历对象

getTime（），将日历对象转化为date对象

add(int field,int amount)，对于日历参数进行加减

getTimeInMillies()，获得毫秒数

#### 3、时间格式化类DateFormat、SimpleDateFormat

**两个格式化类都是线程不安全的**

1、dateFormat是一个抽象类，提供实例化自身的方法:

getDateInstance（int style, Locale aLocale）日期格式化 2019-11-11

getDateTimeInstance（int style, Locale aLocale）日期+时间格式化 2019-11-11 12：22：32

它们有两个参数，int style（格式化风格）, Locale aLocale （语言环境）；从而确定时间的表达方式

2、 simpleDateFormat("yyyy-MM-dd HH:mm:ss")：构造方法，创建时间格式化对象，并指定格式化模板

有多个构造方法，还可以指定语言环境，或使用默认解析模板和语言环境（Locale.CHINA）；相对于DateFormat使用模板更加方便、灵活

模板含义：

| 字母 | 含义                                                         | 示例                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| y    | 年份。一般用 yy 表示两位年份，yyyy 表示 4 位年份             | 使用 yy 表示的年扮，如 11； 使用 yyyy 表示的年份，如 2011    |
| M    | 月份。一般用 MM 表示月份，如果使用 MMM，则会 根据语言环境显示不同语言的月份 | 使用 MM 表示的月份，如 05； 使用 MMM 表示月份，在 Locale.CHINA 语言环境下，如“十月”；在 Locale.US 语言环境下，如 Oct |
| d    | 月份中的天数。一般用 dd 表示天数                             | 使用 dd 表示的天数，如 10                                    |
| D    | 年份中的天数。表示当天是当年的第几天， 用 D 表示             | 使用 D 表示的年份中的天数，如 295                            |
| E    | 星期几。用 E 表示，会根据语言环境的不同， 显示不 同语言的星期几 | 使用 E 表示星期几，在 Locale.CHINA 语 言环境下，如“星期四”；在 Locale.US 语 言环境下，如 Thu |
| H    | 一天中的小时数（0~23)。一般用 HH 表示小时数                  | 使用 HH 表示的小时数，如 18                                  |
| h    | 一天中的小时数（1~12)。一般使用 hh 表示小时数                | 使用 hh 表示的小时数，如 10 (注意 10 有 可能是 10 点，也可能是 22 点） |
| m    | 分钟数。一般使用 mm 表示分钟数                               | 使用 mm 表示的分钟数，如 29                                  |
| s    | 秒数。一般使用 ss 表示秒数                                   | 使用 ss 表示的秒数，如 38                                    |
| S    | 毫秒数。一般使用 SSS 表示毫秒数                              | 使用 SSS 表示的毫秒数，如 156                                |

**只使用单个字母时，代表第二位数为0时，不需要展示：04 -> 4**

3、两者的常用方法：

format(Date date)，将时间按照格式化模板转化为字符串

parse(String time),将满足格式化模板的字符串，转化为date对象

**无论是DateFormat或是SimpleDateFormat，它们都是线程不安全的，因此在多线程中使用是需要避免**

### 7、数字和数字格式化类

#### 1、BigDecimal

​	对于double双精度浮点型，只能处理16位有效数，并且在进行String转double类型的过程中，由于是使用科学计数法存储，会有精度丢失，在进行运算后，进行打印或比较时，就会发生意想不到的结果

​	因此在出现小数的计算和比较时，应该使用BigDecimal进行处理：

BigDecimal提供一系列API，来实现加减乘除、取余和比较：

| 方法                      | 作用 |
| ------------------------- | ---- |
| **add(BigDecimal)**       | 加   |
| **subtract(BigDecimal)**  | 减   |
| **multiply(BigDecimal)**  | 乘   |
| **divide(BigDecimal)**    | 除   |
| **setScale（）**          | 取整 |
| **compareTo(BigDecimal)** | 比较 |

**BigDecimal的创建：**

和包装类一致，提供构造器和valueOf（），推荐使用valueOf（），这样即使使用double、float类型参数，也会自动调用Double.toString(val)，避免精度丢失

#### 2、NumberFormat、DecimalFormat

**两个格式化类都是线程不安全的**

**1、NumberFormat，是一个抽象类，有四个方法来获得实例化对象**

1. 使用getInstance或getNumberInstance获取正常的数字格式。
2. 使用getIntegerInstance得到的整数格式。
3. 使用getCurrencyInstance来获取货币数字格式。
4. 使用getPercentInstance获取显示百分比的格式。

它们有一个Local参数，来指定对于的语言环境

之后通过以下方法，来调整格式化对象的默认参数：

format.setParseIntegerOnly(true)；//设置字符串解析成数字时，是否应该仅作为整数进行解析，此方法只影响解析，与格式化无关

format.setMinimumFractionDigits(2);//设置数值的【小数部分】允许的最小位数

format.setMaximumFractionDigits(3);//设置数值的【小数部分】允许的最大位数

format.setMinimumIntegerDigits(1);//设置数值的【整数部分】允许的最小位数

format.setMaximumIntegerDigits(5);//设置数值的【整数部分】允许的最大位数

**这四个位数的设置，会直接将数字的整数进行截取，小数部分进行舍入；最小位数不足，则补o**

format.setGroupingUsed(false)；//关闭分组，NumberFormat默认使用千位符分隔

format.setRoundingMode(RoundingMode.XXX);//设置舍入模式，一般常用四舍五入RoundingMode.HALF_UP

，默认为HALF_EVEN：

5以上不管是奇数还是偶数，5都舍入，5以下不管是奇数还是偶数，5都舍去；当是5时，若前一位是奇数，5就舍入，若前一位是偶数，5就舍去      

**format.parse("12213.1")：解析后会返回一个Number对象，然后通过XXXvalue来转化为对应的基本数据类型**

**2、DecimalFormat是NumberFormat的实现类，使用模板来进行数字的格式化**

| **No.** | **标记** | **位置**   | **描述**                                                     |
| ------- | -------- | ---------- | ------------------------------------------------------------ |
| 1       | 0        | 数字       | 代表阿拉伯数字，每一个0表示一位阿拉伯数字，如果该位不存在则显示0 |
| 2       | #        | 数字       | 代表阿拉伯数字，每一个#表示一位阿拉伯数字，如果该位不存在则不显示 |
| 3       | .        | 数字       | 小数点分隔符或货币的小数分隔符                               |
| 4       | -        | 数字       | 代表负号                                                     |
| 5       | ,        | 数字       | 分组分隔符                                                   |
| 6       | E        | 数字       | 分隔科学计数法中的尾数和指数                                 |
| 7       | ;        | 子模式边界 | 分隔正数和负数子模式                                         |
| 8       | %        | 前缀或后缀 | 数字乘以100并显示为百分数                                    |
| 9       | \u2030   | 前缀或后缀 | 乘以1000并显示为千分数                                       |
| 10      | ¤\u00A4  | 前缀或后缀 | 货币记号，由货币号替换。如果两个同时出现，则用国际货币符号替换。如果出现在某个模式中，则使用货币小数分隔符，而不使用小数分隔符。 |
| 11      | ,        | 前缀或后缀 | 用于在前缀或或后缀中为特殊字符加引号，例如 "'#'#" 将 123 格式化为 "#123"。要创建单引号本身，请连续使用两个单引号："# o''clock"。 |

DecimalFormat decimalFormat = new DecimalFormat("#0.000%");//获得百分数格式化

DecimalFormat 支持所有Number实现类对象的格式化转换

**NumberFormat、DecimalFormat同时间格式化类一样，线程不安全**

### 8、JDK8日期时间API：

**Date、Calendar的缺点：**

- Date在不进行格式化前提下，打印日期的可读性差
- Date需要搭配Calendar，才能更好处理复杂的时间要求（包括时区转化、年月日处理。。。），也从而导致代码冗余，操作繁琐
- 它们及其DateFormat（时间格式化类）都不是线程安全的，使用时需要考虑并发问题

**新API：**

#### 1、Instant：

用于代替Date类，其时间格式为2020-11-06T08:01:05.376Z，默认表示伦敦时间(0度经线时间)，T为时间与日期的分隔符，Z表示当前为0时区；**用于统一所有时间对象对应的毫秒数计算，以0时区为基准，而不像Date类会根据系统默认时区的变化而变化**

- toEpochMilli（），获取1970开始到现在的毫秒数
- atOffset（ZoneOffset.ofHours(8)）,获取+8区的时间对象（OffsetDateTime,该对象可以进一步转化为日期时间对象）
- ofEpochMili（long time），通过毫秒数转化为instant对象

#### 2、LocalDateTime、LocalDate、LocalTime：

​	该三个类用于代替Calendar类，分别对应：日期+时间、日期、时间；使开发者更加简便的获取想要的时间格式。对于时间，默认精确到毫秒，时区使用当前系统时区：

```java
2020-11-09T11:10:10.215   日期+时间
2020-11-09				  日期
11:10:10.216			  时间
```

​	三个类的使用方式基本一致：

- now（），获取当前时间对象，并可以进行toString的格式化打印

- getXxx（），获取当前时间对象中某个参数值，如年、月、日、星期等

- withXxx（），设置当前时间对象中某个参数值，如年、月、日、星期等

- of（），同时设置多个参数值

- minusXxxx()：减   plusXxx() :加，对时间对象进行相应计算

- toInstant(ZoneOffset.of("+8"));  将时间对象转化为instant对象

- ofEpochSecond（epochSecond, nanoOfSecond, offset）；通过秒数，来定义实际对象

- toEpochSecond（）：获取当前实际对象的秒数

- get（TemporalField）：通过ChronoField枚举（TemporalField接口的实现），获取指定形式的时间数据，返回int类型

- getLong（TemporalField）：和get（TemporalField）一致，用于查询数据类型为long的（可以通过枚举的value范围进行判断）

  **Date和LocalDateTime转化：**

JDK8中，对Date对象进行了修改，从而兼容新时间API，提供了Date和instant对象的转化，从而也就可以实现和LocalDateTime的转化：

```java
LocalDateTime time =date.toInstant().atOffset(ZoneOffset.of("+8")).toLocalDateTime();

Date.from(time.toInstant(ZoneOffset.of("+8")))
```

我们可以看到，在进行时间处理时，有一个重要参数**ZoneOffset**，即时差偏移量，因为**instant只能用于表示本初子午线上的时间**，需要通过该参数进行转化，通过instant来获取当前时间的秒数、毫秒数、纳秒数

而LocalDateTime类，就需要先根据ZoneOffset，转化为instant，然后才能获取当前时间的秒数、毫秒数、纳秒数

#### 3、DateTimeFormatter：

时间格式化类，需要搭配LocalDateTime、LocalDate、LocalTime使用，并且线程安全

- 日期转字符串：

  ```java
  	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
  	LocalDateTime now = LocalDateTime.now();
  	String format = now.format(formatter);
  ```

- 字符串转日期

  ```java
  	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
  	LocalDateTime now = LocalDateTime.parse("2020/07/08 11:45:44",formatter);
  ```

#### 4、TemporalAdjusters:

​		时间调制器，JDK8在TemporalAdjusters工具类中提供一些常用的TemporalAdjuster（时间调制器），通过LocalDate、LocalDateTime的**with(TemporalAdjuster adjuster)**方法，进行一些复杂的时间变化：

- 当月第一天
- 当月第一个星期的周几
- 下周周几
- 当年第一天

### 9、JDK8-Stream流

**Stream类提供了以函数编程式方式操作容器（包括文件等），从而减少部分繁琐操作的代码编写，让程序员写出高效率、干净、简洁的代码（效率会存在一定差异，但影响不大，因此推荐使用Stream操作容器）**

**Stream类特点：**

- 无存储，它本身并不是一种数据类型，而是某种数据源的视图
- stream所执行的操作并不会影响原数据
- stream的中间操作都是惰性执行，不会立即执行，而是等到用户需要时才会执行（调用终止操作时）
- stream只能被遍历一次，类似于容器的迭代器，在调用终止操作方法时，才会按顺序执行所有中间操作，而每一步都遍历一次生成新的Stream

**Stream对象的获取：**

```java
collection.stream()    //获取collection集合的流
Arrays.stream(array)	//通过Arrays工具类，获取指定数组的流
```

**Stream对象常用方法：**

**1、forEach（）**，迭代流中的每个数据，属于终止操作

Collection.forEach()和Collection.stream().forEach()的对比：

- 相同点：

  两者都使用的函数式编程方式，基于Lamda表达式简化代码

- 不同点：

  1、前者使用的是集合的迭代器，其元素的处理顺序是明确的；而后者由于数据存在中间操作，因此遍历处理的顺序是不明确的；

  2、前者由于fail-fast机制，在遍历中修改元素个数时，会直接抛出异常；而后者会在处理完成后，再抛出异常

**综上所述，如果单纯只是进行遍历，可以直接使用Collection.forEach()**

**2、filter（）**，过滤指定数据，属于中间操作

```java
int [] i= {1,2,3};
Arrays.stream(i).filter(action->action==1).forEach(action->System.out.println(action));
```

filter的参数Leamda的返回值需要是boolean类型，保留返回true的数据

**3、limit（）**,截取前N个数据，属于中间操作

```java
int [] i= {1,2,3};
Arrays.stream(i).limit(2).forEach(action->System.out.println(action));
```

limit参数指定的N从1开始，代表截取到第N个元素

**4、skip（）**，跳过前N个数据,属于中间操作

```java
int [] i= {1,2,3};
Arrays.stream(i).skip(2).forEach(action->System.out.println(action));
```

参数和limit一致

**5、sorted（）**，对数据进行排序，属于中间操作

- 对于已实现Comparable 比较器接口的实现类（或基础数据类型数组），直接使用无参方法，实现排序

```java
String [] arrayStrings = {"1","3","2"};	
Arrays.stream(arrayStrings).sorted().forEach(action->System.out.println(action));
```

- 对于未实现Comparable比较器接口的实现类，使用有参构造方法，指定Comparator比较器

```java
ArrayList<User> listUser = new ArrayList<User>();
listUser.stream().sorted(new Comparator<User>() {
	@Override
	public int compare(User o1, User o2) {
		return o1.getAge().compareTo(o2.getAge());
		}
});

//基于Comparator的comparing方法，引入函数式编程
listUser.stream().sorted(Comparator.comparing(new Function<User, Integer>() {
		@Override
		public Integer apply(User t) {
			return t.getAge();
		}
}));

//然后通过lamda表达式和方法引用简化
listUser.stream().sorted(Comparator.comparing(User::getAge));
```

**6、distinct()**，去重，属于中间操作

```java
String [] arrayStrings = {"1","2","2"};	
Arrays.stream(arrayStrings).distinct().forEach(action->System.out.println(action));
```

和set去重一样，需要重写hashCode和equals方法

java三种去重方式：

- 常规遍历放入新数组，可以保证有序性（如果存在就舍弃，并且不需要重写方法，没有入侵性，但效率慢）
- 使用set集合去重（将元素放入set中，然后转为list）
- 基于Stream的distinct去重

**7、mapToInt、mapToDouble，mapToLong**，将所有元素转换为int、Double、Long值，获得一个新的Stream，然后进一步处理，属于中间操作

```java
arrayList.stream().mapToInt(User::getAge).forEach(age->System.out.println(age));
```

**参数类型需要和方法指定类型一致**

**8、map**，元素转换为另一个对象，获得一个新的Stream<T>,然后进一步处理，属于中间操作

```java
Stream<Integer> map = arrayList.stream().map(User::getAge);
```

**参数类型需要和方法指定类型一致**

**9、max，min，sum，avg，count 、summaryStatistics**（封装对象，包含前面所有统计值），对所有元素值进行统计（类似于sql聚合函数），需要搭配IntStream、DoubleStream和LongStream对象使用，因此一般和mapToInt连用(**对于搭配Stream<T>,只支持count、max、min，并且对于max、min需要指定比较器**)，属于终止操作

```java
IntStream mapToInt = Arrays.stream(arrayStrings).mapToInt(action -> Integer.valueOf(action));
OptionalInt max = mapToInt.max();
int asInt = max.getAsInt();
```

OptionalInt,类似于Optinal，但只对于与Int基础类型数据

**10、findFirst()** ，取第一个元素，属于终止操作

```java
String[] arrayStrings = { "1", "3", "2" };
Optional<String> findFirst = Arrays.stream(arrayStrings).findFirst();
String firstString = findFirst.get();
```

Optinal,JDK8引入的一种包装类，用于解决NPE问题，减少对空指针的判断

**11、flatMap（）**,类似于Map，但是要求元素是一个可分解的容器集合，而获取的新Stream是针对于该容器的元素类型，比如原Stream类型为Stream<List<Integer>>，就可以转换为Stream<Integer>,实际场景就是，**获取多个集合中的所有元素**、**多个字符串获取所有单个的字符**

```java
ArrayList<List<String>> list = new ArrayList<List<String>>();
Stream<String> flatMap = list.stream().flatMap((Function<List<String>, Stream<String>>)action ->action.stream());
```

在函数接口Funcation参数中，参数action类型必须手动指定，(Function<List<String>, Stream<String>>)，前者为当前Stream流中的集合元素类型，后者为需要拆分的类型生成的Stream

**12、reduce（）**,通过所有元素，生成一个值，本质上和max等方法一致，自定义统计方法；属于终止操作

reduce提供三种重载方法：

- 参数列表：BinaryOperator<T> accumulator，其函数接口方法参数有两个，第一个为上一次函数接口方法执行的结果，第二个为当前Stream中的元素，因此可以实现**累加器功能**（一般情况下，选择集合方法代替）

```java
list.stream().MaptoInt.mapToInt(User::getAge).reduce((x,y)->x+=y);
```

- 参数列表：T identity, BinaryOperator<T> accumulator,与第一个类似，但提供了一个额外参数，来指定BinaryOperator方法参数中累加结果的初始值

```java
arrayList.stream().mapToInt(User::getAge).reduce(100,(x,y)->x+=y);
```

- 参数列表：U identity,BiFunction<U, ? super T, U> accumulator,BinaryOperator<U> combiner,实现累加器的同时，可以将结果封装为一个对象返回，用于操作元素多个字段的累加（**因此不需要搭配mapToInt筛选需要的单个数据**）,用于比较复杂的数据统计。但**这时反而使用正常的for循环遍历处理，代码更加简单**

**12、toArray（）**，将流数据放到数组中，属于终止操作

```java
list.stream().toArray();
```

**13、collect（）**，将流数据放到指定集合中，属于终止操作

Stream类同包下，提供一个**Collectors工具类**，用于搭配collect方法将数据存入指定容器;除了单纯的存放数据外，collect方法还可以实现聚合、分组（多级分组）、分区、拼接 高级操作

- 将数据单纯放入容器

```java
//默认使用ArrayList
List<User> collect = arrayList.stream().distinct().collect(Collectors.toList());
//默认使用HashSet
Set<User> collect = arrayList.stream().distinct().collect(Collectors.toSet());
//自定义容器类型
LinkedList<User> collect = arrayList.stream().distinct().collect(Collectors.toCollection(LinkedList::new));
```

- 实现自定义聚合

```java
Optional<User> collect = arrayList.stream().collect(Collectors.minBy((Comparator.comparing(User::getAge))));
```

- 分组

  根据某个值，将数据进行分组

```java
Map<Integer, List<User>> collect = arrayList.stream().collect(Collectors.groupingBy(u -> u.getAge()));
```

- 分区

  将数据分为true，false两类

```java
Map<Boolean, List<User>> collect = arrayList.stream().collect(Collectors.partitioningBy(u -> u.getAge() > 0));
```

- 拼接

  首先需要获取一个Stream<String>的对象（因此就需要使用map，在原容器元素中获取String类型的值），然后再进行collect的拼接方法

```java
String collect2 = arrayList.stream().map(user->user.getUsername()).collect(Collectors.joining());
```

### 10、JDK8-函数式接口

**函数式接口：**表示有且只有一个抽象方法的接口

**注意：**

1、在JDK8中，需要接口方法通过default进行实现，这些方法并不属于抽象方法，因此函数式接口也就可以存在非抽象方法

2、当接口声明由Obejct类提供的方法抽象时，会自动被Object类完成该抽象方法的实现，因此不能将其看作为抽象方法

```java
@FunctionalInterface
public interface FunctionalDemo {
	String getName();
    
    //被Obejct实现
    boolean equals(Object obj);
    
    //默认实现
	default void  setName(String name){
		System.out.println(name);
	}
}
```

**@FunctionalInterface:**

​	JDK8中提出，用于注解在接口上，表示该接口为函数式接口，并交给编译器进行编译期检查，类似于@Override

**函数式接口的作用：**

​	用于转换为Lambda表达式，来简化接口实例化方式

其实，在JDK8之前，就存在一些函数式接口，一般通过匿名类方式实现，比如：Runnable、Callable等；在JDK8时，提供了java.util.function包，类别提供了需要通用的函数式接口，从而基于Lambda表达式，方便一系列功能对象的创建，并将其作为参数，在其方法调用时，动态定义函数式接口方法内部的实现规则；**极大程度上，方便了通用方法的编写**

**常用函数式接口：**

- Supplier接口，用于表示一个对象（提供者）

```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

- Consumer接口，用于操作一个对象（消费者）

  提供一个默认方法，实现两个Consumer对象的连续操作

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
    
    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

- Predicate接口，用于操作一个对象，返回boolean（断言）

  提供三个默认方法，实现Predicate的与、或、非操作

  提供一个静态方法，快速数据一个判断两个对象引用是否相等的Predicate实现对象

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
    
    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }
    
    default Predicate<T> negate() {
        return (t) -> !test(t);
    }
    
    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }
    static <T> Predicate<T> isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -> targetRef.equals(object);
    }
}
```

- Funcation接口，通过一个对象获取另一个对象（函数）

  提供两个默认实现方法，进行入参和返回值的非空处理

  提供一个静态方法，用于返回参数本身

```java
 */
@FunctionalInterface
public interface Function<T, R> {

    R apply(T t);

    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }
    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
}
```

### 11、JDK8-Lambda表达式

​	用于简化**创建只有一个抽象方法接口（函数式接口）的实例**  的代码

**1、使用场景：**

- 容器进行迭代操作：容器实现的Iterable接口都提供了一个forEach方法：它实现了对容器迭代器内部属性和容器内部对象的操作，该方法是 以Consumer接口的实例化作为为参数，该接口有一个需要重写的accept方法，即为操作容器内部对象的方法
- 事件监听：事件监听器一般会提供需要重写方法，用于事件触发时执行
- 多线程实例化：重写线程Runnable接口的run方法
- java.util.function 提供Predicate接口，提供一个filter方法，用于在使用容器forEach方法迭代的同时，以变化条件作为参数Predicate，从而满足不同判断条件下的forEach遍历

**2、lambda表达式写法**：

​	lambda表达式由三部分组成，参数列表，箭头（->），方法语句，简写要求如下：

- 如果只有一个参数时，可以简化参数括号；没有参数则使用（）
- 参数列表中的类型可以省略（非泛型参数时），但要保证参数顺序一 一对应（否则会出现检查时异常）
- 方法语句只有一行代码时，冒号和大括号可以省略
- 方法语句有多行代码，并且需要返回值时，最后显示进行return 返回（虽然可以根据返回值类型进行自动检测，从而省略return的，但是这样代码可读性低）
- 在方法语句省略return时，不能自动识别子类，进行向上转型，必须保证方法语句的返回值类型与实际类型一致

### 12、JDK8-方法引用

​	用于**简化lambda表达式的语法糖**，即lambda表达式的另一种表现形式

**1、使用条件：**

​	当Lambda表达式的方法体中仅仅只是调用已经存在的方法时，并且除了调用动作外，没有任何其他多余动作，则可以使用方法引用 这个语法糖来简化lambda表达式

**2、类型：**

| 方法调用类型                               | 方法引用（语法糖）       | 对应lambda表达式                 |
| ------------------------------------------ | ------------------------ | -------------------------------- |
| 静态方法                                   | 类名：：静态方法名       | （args）—>A.staticMethod（args） |
| 实例方法（实例对象在内部类所在作用域中）   | 实例对象变量名：：方法名 | （args）—>instA.Method(args)     |
| 对象方法（实例对象作为内部类方法参数传入） | 类名：：方法名           | (instA,args)—>instA.Method(args) |
| 构造方法                                   | 类名：：new              | (args) —> new  A(args)           |

### 13、JAVA反射

**反射：**

​	指程序可以访问、检测和修改它本身状态或行为的一种能力；在面向对象编程过程中，java反射机制可以在程序运行时，动态加载类并获取类的详细信息，从而操作类或对象的属性、方法。本质上，就是JVM获取class对象，然后通过对class对象反编译，来获取对象的各种信息

​	因此在java这种先编译后运行的语言中，反射能让我们更灵活的编写代码，将对象在运行时动态装配，更容易实现面向对象编程

**反射的缺点：**

​	1、反射需要消耗一定的系统资源，因此只有需要动态获取一个对象时，才使用反射

​	2、反射调用方法时会忽略访问权限检查，因此会破坏类的封装性

**反射机制的使用：**

​	java提供java.lang.reflect反射包，来实现反射，而class对象就是反射入口对象，包含了当前类对于class文件中的所有信息

- 获取class对象：

  ```java
  Class<?> perClazz = Class.forName("reflect_fanshe.Person");//Class类的静态方法
  Class<?> perClazz2 = Person.class;//类名.class
  
  Person person = new Person();//通过对象获取class
  Class<?> perClazz3 = person.getClass();
  
  ```

  **这三种方式，都可以获取类的class对象，并且JVM能够保证该对象为单例**

- 通过class对象获取类信息

  - **Constructor类，表示类的构造方法，通过class对象的如下方法获取：**

    | 方法                                               | 作用                                   |
    | -------------------------------------------------- | -------------------------------------- |
    | getConstructor(Class...<?> parameterTypes)         | 获得该类中与参数类型匹配的公有构造方法 |
    | getConstructors()                                  | 获得该类的所有公有构造方法             |
    | getDeclaredConstructor(Class...<?> parameterTypes) | 获得该类中与参数类型匹配的所有构造方法 |
    | getDeclaredConstructors()                          | 获得该类所有构造方法                   |

    **对于不带有Declared关键字方法，只会获取（public）公开元素；带有Declared关键字方法，则会获取所有元素**

  - **Method类，代表类的普通方法**

    和getConstructor的四个方法类似，为getMethods....

  - **Field类,表示类的成员变量**

    和getConstructor的四个方法类似，为getFields....

  - **Annotation类，表示类的注解**

    和getConstructor的四个方法类似，为getAnnotations....

    由于JDK8提供了@Inherited新注解，实现一个地方可以提供多个相同注解，因此也提供getAnnotationsByType方法，更具指定注解类型，来获取多个Annotation对象数组

    **对于不带有Declared关键字方法，只会获取当前类的注解；带有Declared关键字方法，则获取所有当前类及父类注解**

  - **其他重要方法,用于获取类的一些信息**

    | 方法                   | 作用                                           |
    | ---------------------- | ---------------------------------------------- |
    | isAnnotation()         | 是否为注解类型                                 |
    | isAnonymousClass()     | 是否为匿名内部类                               |
    | isArray()              | 是否为数组                                     |
    | isEnum()               | 是否为枚举                                     |
    | isInterface()          | 是否为接口                                     |
    | isLocalClass()         | 是否为局部内部类                               |
    | isMemberClass()        | 是否为内部类                                   |
    | isInstance(Object obj) | 是否为某个对象实例                             |
    | getName()              | 获取全类名                                     |
    | getPackage()           | 获取包名                                       |
    | getSimpleName()        | 获取类名                                       |
    | getSuperclass()        | 获取继承的父类的class                          |
    | getInterfaces()        | 获取实现的接口class数组                        |
    | newInstance()          | 获取当前类的实例（调用默认构造器，没有回报错） |

- Field对象方法：

  | 方法                                                         | 作用                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | getName()                                                    | 获取字段名                                                   |
  | getType()                                                    | 获取字段类型的class对象                                      |
  | getModifiers（）                                             | 获取字段的权限修饰符，返回int类型，通过Modifier.toString（x）进行字符转换 |
  | get（Object obj）                                            | 获取指定实例中，该字段的值（还提供其他八种基础数据类型）     |
  | set（Object obj，Object obj ）                               | 设置指定实例的字段值（还提供其他八种基础数据类型）           |
  | isAnnotationPresent(Class<? extends Annotation> annotationClass) | 是否存在该注解                                               |
  | getAnnotation(Class<T> annotationClass)                      | 获取该字段上Annotation注解对象()                             |
  | getAnnotations()                                             | 获取字段上的所有Annotation注解对象数组（和getDeclaredAnnotations作用一样） |
  | isAccessible()                                               | 字段是否可以直接访问（默认private字段不能通过反射访问，返回false） |
  | setAccessible()                                              | 设置该字段是否可以直接访问（本质就是关闭访问权限的安全检查，如果为false，则get、set方法就会抛出异常） |
  | equals(Object obj)                                           | 比较两个对象是否为同一个Field对象，即来源于同一个class对象中的Field |

- Method对象方法：

  | 方法                                                         | 作用                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | getName（）                                                  | 获取方法名                                                   |
  | getReturnType()                                              | 获取返回值类型                                               |
  | getModifiers()                                               | 获取方法权限修饰符                                           |
  | getParameterTypes()                                          | 获取参数类型class对象数组                                    |
  | getAnnotations()                                             | 获取方法上的所有Annotation注解对象数组(和getDeclaredAnnotations作用一样） |
  | isAnnotationPresent(Class<? extends Annotation> annotationClass) | 方法上是否存在该注解类型                                     |
  | getAnnotation(Class<T> annotationClass)                      | 获取方法上的该注解                                           |
  | setAccessible(Boolean bool);                                 | 设置方法是否能直接执行（本质就是关闭访问权限的安全检查，如果为false，则inoke方法就会抛出异常） |
  | isAccessible()                                               | 方法是否能直接执行                                           |
  | invoke（Object obj, Object... args）                         | 执行方法，提供该方法实例对象，方法参数（如果方法为静态方法，则不需要实例对象，使用null替代） |
  | equals(Object obj)                                           | 比较两个对象是否为同一个Method对象，即来源于同一个class对象中的Method |

- **Constructor对象方法**

  | 方法                             | 作用                                                         |
  | -------------------------------- | ------------------------------------------------------------ |
  | newInstance(Object ... initargs) | 通过相应构造器参数，获取类的实例对象                         |
  | isAccessible()                   | 构造器是否能直接执行（是否为public）                         |
  | setAccessible(Boolean bool);     | 设置构造器是否能直接执行（本质就是关闭访问权限的安全检查，如果为false，则newInstance方法就会抛出异常） |

- Annotation

  Annotation对象是用于操作注解元数据信息，需要搭佩@interface（注解类）使用：

  - 注解的基本使用：

    - 定义注解

    ```java
    @Target(ElementType.TYPE)  //注解的作用域，常用有TYPE（类、接口、枚举、注解)、FIELD(字段、枚举常量)、METHOD（方法）、PARAMETER（方法参数）
    @Retention(RetentionPolicy.RUNTIME)//注解的声明周期，一般情况下，就是RNUTIME，一直到运行阶段
    public @interface DataTest {
        //注解属性，需要有（），并且可以使用default关键字提供默认值
        String value() default "";
    }
    ```

    - 注解使用

    在注解处理器代码内部，通过反射机制来获取类、成员变量、方法、构造方法上的注解元数据，然后进行相应处理，而获取方式，就是用通过Annotation对象进行操作

  - Annotation对象常用方法：

    | 方法           | 作用                              |
    | -------------- | --------------------------------- |
    | equals         | 判断是否为通过Annotation对象      |
    | annotationType | 获取当前Annotation对象的class对象 |

    **然后其他元数据的获取，则根据注解本身的方法提供**

**综上所述，java反射的使用，就是对Class、Field、Method、Annotation、Constructor各个类的API使用**

### 14、JDK-Optional容器

​	Optional是一个容器对象，用于存储一个对象或者null，方便开发者不需要显式的进行空值检查，而是通过他的一系列方法来完成

**Optional作用：**

​	1、显式提醒开发者，Optional容器中的对象可能/不可能为null

​	2、避免if-notNull的判断

**Optional方法：**

- 创建Optional对象

  

### 15、字符串格式化器MessageFormatter

### 16、file与i/o流（files工具类）

## 编码格式

### 1、常见编码格式或相关

**1、ASCII码：**

​	基于字母的一套计算机编码，共由128个字符组成，单字节编码，将西文字符转化为二进制数

**2、ISO-8859-1：**

​	在ASCII码的基础上扩展升级，支持256个字符串，覆盖了大多数西欧语言字符，单字节编码，可以向下兼容ASCII码

**3、GB2312：**

​	中文字符编码，包括683个符号和6763个汉字，支持汉字和所有西欧字符，双字节编码，可以向下兼容ISO-8859-1（西欧字符使用单字节表示）

**4、GBK：**

​	对GB2312的扩展，可以支持21003个汉字，兼容GB2312

**5、Unicode：**

​	UniversalCode，统一码，并不是一个编码格式，而是一种全世界语言通用的字符集编码表。它为所有字符都设置一个对应唯一的16进制编码，并添加前缀\u，叫做Unicode的码点，所有语言文字都可以用其表示，如A表示\u0041。Unicode只是定义了所有字符对应的码点，但并没有定义码点的二进制存储规则

**6、UTF-16：**

​	UTF-16是Unicode码点的一种存储方式，即编码规则，使用两个字节进行存储，可以组合65535个字符，满足全世界所有文化的符号使用，但是不兼容其他单字节编码（ASCII码、ISO-8859-1）

**7、UTF-8：**

​	对于UTF-16的优化，使用1-4个字节来存储unicdoe码点，使用单字节存储西欧字符，向下兼容ASCII码、ISO-8859-1。对于中文汉字，使用3或4个字节存储unicode码点

**8、ANSI：**

​	ANSI并不是一个编码格式，而是一套字符代码，对于全世界字符，可以有效选择相应编码格式进行存储，如中文系统使用GBK、英文系统使用ASCII码

**9、URL编码：**

​	URL默认只支持英文字符、数字和一些保留字符，因此对于如汉字就无法正常传输，因此就需要使用URL编码来解决

​	URL编码规则：

​	1、对于一些特殊字符，使用ASCII码转换，然后将码值转换为16进制表示，最后加上前缀 %，如空格，为%2B

​	2、对于ASCII码无法转换的字符（如汉字），使用utf-8转换为二进制数，然后再转换为16进制表示，每个字节添加都前缀 %，如春节，为%E6%98%A5%E8%8A%82

### 2、JAVA编码格式使用

**1、编码与解码的定义：**

​	字符转化为二进制，叫做编码

​	二进制转化为字符，叫做解码

**2、java中的编码格式：**

- java内部使用utf-16BE编码格式，将字符存储在内存中

- java对于String类型数据进行编码和解码时，如果不指定编码格式，则默认使用系统环境中的文件编码：

```java
String csn = Charset.defaultCharset().name();
//如果系统环境的文件编码获取失败，则使用UTF-8
String csn = AccessController.doPrivileged(new GetPropertyAction("file.encoding"));
Charset cs = lookup(csn);
if (cs != null)
	defaultCharset = cs;
else
	defaultCharset = forName("UTF-8");
```

​	通过设置JVM中的**file.encoding**参数，来改变java内部默认编码格式：

如果没有设置JVM启动参数：-Dfile.encoding=utf-8，则默认使用系统环境编码（windows默认GBK、Linux默认UTF-8）

- 控制台编码

  进行控制台打印时，使用PrintStream类来输出，并且使用java默认编码格式输出，而控制台展示时，其编码和java默认编码格式如果不一致，就会导致乱码

- I/O流字节流转字符流编码

  为了保证不乱码，需要保证字节转字符解码使用的编码格式和字节原本的编码格式一致，默认使用系统环境编码

- 文件字节流编码

  对于文件字节输入流，会使用文件本身编码格式读取，获取其二进制数据

## 文件路径

### 1、路径分隔符

- Windos使用反斜杆（\）
- Linux使用正斜杠（/）

JAVA获取当前系统的路径分隔符：

```java
String separator = System.getProperty("file.separator");
```

### 2、文件路径URL获取方式

JDK提供java.net.URL类，对url统一资源定位符进行相关API处理：

而文件路径、网络路径都属于URL范畴，由protpcol（协议）、host（主机）、port（端口）、path（路径）、query（请求参数）

| 方法        | 作用                                   |
| ----------- | -------------------------------------- |
| getProtocol | 协议（文件路径则为file）               |
| getHost     | 主机ip（文件路径为空）                 |
| getPort     | 端口（文件路径为-1）                   |
| getPath     | 路径（文件路径为整个磁盘路径）         |
| getFile     | 路径包含传参（文件路径为整个磁盘路径） |
| getQuery    | 传参（文件路径返回null）               |

- 获取项目class目录的绝对路径：

  ```java
  this.getClass().getClassLoader.getResource("").getPath();
  this.getClass().getResource("/").getPath();
  ```

- 获取项目下，指定文件的绝对路径：

  ```java
  this.getClass().getClassLoader.getResource("template/test.xlsx").getPath();
  this.getClass().getResource("/template/test.xlsx").getPath();
  ```

  Class.getResource和ClassLoader.getResource本质上是一样的，都是通过ClassLoader来加载资源，但Class.getResource对于相对路径name参数会进行额外处理：**对于/开头的name，自动截取掉"/"第一个字符**

  - **Class.getResource：**

    无论是否/开头，都会从项目class目录下获取资源

  - **ClassLoader.getResource：**

    如果name不以/开头，则从而项目class目录下获取资源；如果以/开头，则会使用双亲委任模型从最上级类加载器开始加载，而最顶层类加载器BootClassLoader中，getResource默认返回null，因此不能使用/开头

  **注意：**

  ​	**当使用path来进行文件对象创建时，项目是通过jar打包，则获取的路径为xxx/xx.jar/xxx,此时new File（path），无法通过文件路径获取资源，因此只能加载jar包外的文件**

### 3、通过相对路径获取输入流（InputSteam）

- **Class.getResourceAsStream**
- **ClassLoader.getResourceAsSteam**

两者本质上都是通过ClassLoader加载资源，和获取URL类似，获取当前资源的输入流，但该方式可以**有效避免使用文件路径无法获取压缩包下的资源**，通过ClassLoader可以直接通过URL来定位获取资源

### 4、其他目录获取方式

- 通过系统属性，获取项目运行路径（jar包所在的同级目录，war包运行服务器的bin目录）

```java
System.getProperty("user.dir")
```

- 通过web请求，获取当前web项目根目录下的文件路径

```java
request.getSession().getServletContext().getRealPath("/");
```

## 时区

全球按照经线0°开始将全球分为24个时区，每15°作为对于时区的中央经线，因此每个时区相隔1个小时

不同国家所占时区的多少也有不同，因此通过该国家的城市名来划分该国家的所有时区，中国五个时区名为：

Asia/Chongging、Asia/ChungKing、Asia/Harbin、Asia/Kashgar、Asia/Urumqi；但是由于中国统一使用北京时间，因此它们都对应为GMT +08:00

时区使用的标准规则：

1、GMT（格林威治标准时间），通过天文学知识，来定义不同时区的标准时间

2、UTC（世界协调时间），基本和GMT一样，基于原子钟，更加精准，误差在0.9s以内

3、DST（夏日节约时间），在正常时间上，把时间提前一个小时，用于适应夏天日出早，而来控制减少灯光、照明的开支

4、CST：四个时区的缩写，一般不推荐使用，因为java默认使用 中国标准时间，JS使用 美国标准时间

1. Central Standard Time (USA) UT-6:00   美国标准时间
2. Central Standard Time (Australia) UT+9:30  澳大利亚标准时间
3. China Standard Time UT+8:00     中国标准时间
4. Cuba Standard Time UT-4:00     古巴标准时间

## 加密和编码算法

### 1、加密和编码的区别

- 加密：

  加密是将明文转变为一种不可破解的密文，提供内容识别难度

- 编码：

  编码是将内容换了一个体现形式，便于传输并提供可读性

### 2、常用编码算法

- **Base64编码**

  使用64个可打印字符来表示二进制数据的方法，是一种编码算法；二进制数据，本质上就是8位的字节，而64个字符只需要6位二进制数表示，因此取其公倍数24进行转换，即将3 *8的二进制数据转换为4 *6的二进制数据，然后高两位补0，转换为对于字符

  - 编码过程：

    1、将二进制数据分组，每6位一组，最后不足的补0

    2、每组6位的二进制转换为十进制数，对于Base64编码表转换为字符，最后形成一个Base64编码字符串

  - 解码过程：

    1、通过Base64编码表，对Base64字符串中的每个字符进行解码

    2、将每个字符对应的十进制数转换为二进制数，让每8位一组，并删除多余的0

  **注意：**Base64编码对于最后两个字符有许多变种，一般常用有，标准BASE64编码、URLBase64编码、MIMEBase64编码

- **Hex编码**

  和Base64编码类似，将不可读的二进制数据，转化为可显示的字符串数据

  - 编码过程：

    1、将二进制数据中，每个字节一分为二，并将高四位补0得到两个字节

    2、然后使用指定编码格式，对二进制数据进行解码，转换为字符串

  - 解码过程：

    1、使用指定编码格式，对字符串进行编码，获取二进制数据

    2、去除每个字节的高四位，两个组合为一个字节，从而获取原二进制数据

### 3、常用加密算法

加密算法可分为三类：

- **摘要加密**

  摘要加密(Digester)，用于将信息进行加密为固定长度的字符串，作为数字签名，校验传输文件是否被篡改（接受方收到文件后，对内容进行摘要加密，将得到的密文和数字签名比较），因此摘要加密是不可逆加密算法

- **对称加密**

  对称加密（SymmetricCrypto），也叫做私钥加密，加密和解密使用相同密钥，是传统的加密方式，但存在密钥泄露问题，因此对称加密为可逆机密算法

- **非对称加密**

  非对称机密（AsymmetricCrypto）,使用公钥和私钥进行加密和解密，更加使用场景，来选择不同使用方式

  - 签名：使用私钥加密，公钥解密；让所有拥有公钥的人进行解密，获取签名信息，来判断传输信息是否被篡改
  - 加密：使用公钥加密，私钥解密;保证传输信息不被他人获取，但可能会被修改

#### 1、摘要加密

- **MD5加密**

  Message-Digest Algorithm 5 信息摘要算法，为**摘要加密**

  特点：

  - 任意长度明文，加密后都可以变为固定长度的MD5值（128位二进制数据，即16个字节）
  - 不可逆加密，无法反向解密，也因此加密速度较慢

  一般情况下，会将加密得到的16字节数据转换为32个字符,转换规则如下：

  1、对每个字节转换为十进制数（-256~255）

  2、然后分别对其取16的模和商，然后分别对应匹配一个字符，从而将形成32位的字符串

  **1-15对应{"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"}**

- **SHA加密**

  Secure HashAlgorithm 安全哈希算法，为**摘要机密**，和MD5非常类似，加密得到的数据长度为160位，因此更加安全，但机密速度也更慢

#### 2、对称加密

- **DES加密**

  Data Encryption Standard 数据加密标准算法

- **AES加密**

  Advanced Encryption Standard 高级加密标准算法

#### 3、非对称加密

- **RSA加密**

  RSA算法可以用于加密和数字签名，安全性通过**大整数的因式分解的复杂度**来保证

- **DSA加密**

  Digital Signature Algorithm 数字签名算法，相对于RSA加密，只能用于数字签名，但签名生成和校验的速度更快，安全性通过**离散对数问题**保证

注意：由于非对称加密的速度很慢，因此一般情况下，使用对称加密算法进行数据加密，而使用非对称加密算法进行密钥管理和数字签名

## SPI机制

​	SPI（Service provider Interface），服务提供者接口，用于将接口和实现类分离，开发者只需要知道抽象层接口，其实现类由第三方提供者指定，并通过SPI进行服务发现

SPI约定：

​	1、在工程的META-INFO/services/目录下，以指定接口全限定名作为文件名、接口实现类全限定名作为内容（多个实现类，则指定多条数据）

​	2、此时就可以通过ServiceLoader动态加载指定接口的实现类

SPI使用场景：

​	对于日志框架实现、JDBC驱动都可以使用此方式，对于它们接口的实现通过第三方框架自己在工程目录中指定，从而让开发者无需关心这样引入此框架

## 跨域

